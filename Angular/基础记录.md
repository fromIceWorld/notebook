#### :host 和 ::ng-deep

```typescript
:host：表示选择当前组件
::ng-deep：可以忽略中间className的嵌套层级关系。直接找到你要修改的className。
```



#### 指令

##### ngProjectAs

```
在投影视图中，可代替 <ng-container>中的css选择器，直接使用 ngProjectAs = ‘名称’，去匹配
<ng-content select="*"></ng-content> 中的select
```

#### 标签

```
ng-container：不渲染成DOM，显示标签内内容
ng-template:模板元素,牧人内部元素不可见
  1. 加入[ngIf]属性
  2. 添加标识(#标识名称)，使用 ngTemplateOutlet 指令引用
```

#### 依赖注入

```typescript
`要用到的任何服务，你必须至少注册一个提供者`

`1.`服务可以在自己的元数据中把自己注册为提供者,通过配置:providedIn属性，定义提供者的层级{root:模块} 
@Injectable({
    providedIn 
})，

`2.`为特定的模块注册提供者
@NgModule({
  providers: [
   BackendService,
   Logger
 ],
 ...
})
    
`2.`为特定的组件注册提供者
@Component({
  selector:    'app-hero-list',
  templateUrl: './hero-list.component.html',
  providers:  [ HeroService ]
})

---------providers配置----------------------------
useValue useClass useExisting useFactory
providers：{
    provide:  依赖注入的 token
    useValue: 固定值
    useClass: 创建并返回指定类的新实例【程序 new 处理，可遮蔽父级依赖】
    useExisting:把一个令牌映射成另一个令牌(provide)【使用abstract 收窄源 】
    useFactory：指定工厂函数，【调用工厂函数创建依赖实例，搭配deps属性，指定依赖】
    deps：搭配 useFactory 使用
}   
依赖的前向引用forwardRef：
providers: [{ provide: Parent, useExisting: forwardRef(() => AlexComponent) }],
```



#### 路由

```
{
	path:路径名称,
	component：组件，
	redirectTo：重定向，
	pathMatch:'' 指令路由器匹配路由的方式：'full'[完全等于]；'prefix'[匹配开头]
}
```

#### 数据驱动/事件驱动

```typescript
vue：    虚拟DOM，data双向绑定，`改变data`，引发视图更改
Angular：增量DOM，`事件更改`引发data更改，引发视图更改
```



### DOM操作

#### NgTemplateOutlet

```typescript
`内嵌视图的属性`
NgTemplateOutlet是一个对象，第一个属性是模板的标记，第二个是上下文对象，
可通过在模板中使用let进行绑定

@Component({
  selector: 'ng-template-outlet-example',
  template: `
    <ng-container *ngTemplateOutlet="greet"></ng-container>
    <hr>
    <ng-container *ngTemplateOutlet="eng; context: myContext"></ng-container>
    <hr>
    <ng-container *ngTemplateOutlet="svk; context: myContext"></ng-container>
    <hr>

    <ng-template #greet><span>Hello</span></ng-template>
    <ng-template #eng let-name><span>Hello {{name}}!</span></ng-template>
    <ng-template #svk let-person="localSk"><span>Ahoj {{person}}!</span></ng-template>
`
})
export class NgTemplateOutletExample {
  myContext = {$implicit: 'World', localSk: 'Svet'};
}
ngOnChanges() 
```

#### ViewChild/ViewChildren

```typescript
`操作视图本身存在的节点,而不是投影进来的内容`
属性装饰器，
用于配置一个视图查询。 变更检测器会在视图的 DOM 中查找能匹配上该选择器的第一个元素或指令。 如果视图的 DOM 发生了变化，出现了匹配该选择器的新的子节点，该属性就会被更新。

@ViewChild('cmp') 查询 <my-component #cmp></my-component>【字符串形式】 
@ViewChild(SomeService) someService: SomeService 【组件树中子组件所定义的提供者】
@ViewChild('someToken') someTokenVal: any 【通过字符串令牌定义的提供者】
@ViewChild(TemplateRef) template 【查询 <ng-template></ng-template>】

ngAfterViewInit() {
    // child is set
  }
```

#### ContentChild

```typescript
`与内容子节点有关,操作投影进来的内容;`

`<ng-content select="**"></ng-content>`ng-content实现占位，select实现选择器
`ng-content类似于Vue中的插槽`
`@ContentChild 操作投影内容`

用于配置内容查询的参数装饰器。
用于从内容 DOM 获取与此选择器匹配的第一个元素或指令。如果内容 DOM 发生了更改，并且有一个新的子项与选择器匹配，则该属性将被更新。

ngAfterContentInit(): void {
	....
}
```

##### ViewContainerRef

```typescript
`视图容器的实例`
可通过 ViewContainerRef 控制view 中的 容器，将 template 插入到  ng-container ，也可自己创建视图
```

##### ElementRef

```typescript
`DOM 元素`
```

##### TemplateRef

```typescript
`模板` 可创建内嵌视图
```

##### ComponentRef

```typescript
`组件` 创建宿主视图
```

##### ComponentFactoryResolver

```typescript
创建ComponentRef
```