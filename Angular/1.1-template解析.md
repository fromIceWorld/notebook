## æ¨¡æ¿è§£æ

ç»„ä»¶ä¸­çš„ templateè§£æã€1-bootstrapModuleFactory/ 2.1.1.3-loadDirectiveMetadataã€‘ä¸­çš„ `templateMeta`

```typescript
	  const template = metadata.template !;
      const templateMeta = this._directiveNormalizer.normalizeTemplate({
        ngModuleType,
        componentType: directiveType,
        moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),
        encapsulation: template.encapsulation,
        template: template.template,
        templateUrl: template.templateUrl,
        styles: template.styles,
        styleUrls: template.styleUrls,
        animations: template.animations,
        interpolation: template.interpolation,
        preserveWhitespaces: template.preserveWhitespaces
      });
```

### _directiveNormalizerã€DirectiveNormalizerç±»ã€‘

#### normalizeTemplate

```typescript
  normalizeTemplate(prenormData: PrenormalizedTemplateMetadata):
      SyncAsync<CompileTemplateMetadata> {
      ....
      åˆ¤å®š template å’Œ templateUrl æ ¼å¼ä¸ºstringï¼Œæœ‰ä¸”åªèƒ½æœ‰ä¸€ä¸ª;
      preserveWhitespaceså¿…é¡»æ˜¯ boolean ç±»å‹;
      å¦åˆ™æŠ¥é”™

    return SyncAsync.then(
        this._preParseTemplate(prenormData),
        (preparsedTemplate) => this._normalizeTemplateMetadata(prenormData, preparsedTemplate));
  }
1-`preparsedTemplateæ˜¯_preParseTemplateè¿”å›å€¼`{
      template,
      templateUrl: templateAbsUrl,
      isInline,
      htmlAst: rootNodesAndErrors,
      styles,
      inlineStyleUrls,
      styleUrls,
      ngContentSelectors: visitor.ngContentSelectors,
}
2-`è¿è¡Œthis._normalizeTemplateMetadata`
```

##### 1-_preParseTemplate

```typescript
  private _preParseTemplate(prenomData: PrenormalizedTemplateMetadata):
      SyncAsync<PreparsedTemplate> {
    let template: SyncAsync<string>;
    let templateUrl: string;
    if (prenomData.template != null) {
      template = prenomData.template;
      templateUrl = prenomData.moduleUrl;
    } else {
      templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl!);
      template = this._fetch(templateUrl);
    }
    return SyncAsync.then(
        template, (template) => this._preparseLoadedTemplate(prenomData, template, templateUrl));
  }
```

##### 1.1_preparseLoadedTemplate

```typescript
  private _preparseLoadedTemplate(
      prenormData: PrenormalizedTemplateMetadata, template: string,
      templateAbsUrl: string): PreparsedTemplate {
    const isInline = !!prenormData.template; //æ ‡å¿—ä½ï¼Œæ˜¯å¦æ˜¯è¡Œå†…æ¨¡æ¿
    const interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation!);//æ’å€¼æ ¼å¼
      //è¿”å›è·¯å¾„ï¼š `ng:///æ¨¡å—åç§°/ç»„ä»¶åç§°.html` ã€é™„å½•templateSourceUrlã€‘
    const templateUrl = templateSourceUrl(
        {reference: prenormData.ngModuleType}, {type: {reference: prenormData.componentType}},
        {isInline, templateUrl: templateAbsUrl});
      //ã€é™„å½•HtmlParserã€‘è¿”å›å€¼{rootNodes,errors}
    const rootNodesAndErrors = this._htmlParser.parse(
        template, templateUrl, {tokenizeExpansionForms: true, interpolationConfig});
    if (rootNodesAndErrors.errors.length > 0) {
      const errorString = rootNodesAndErrors.errors.join('\n');
      throw syntaxError(`Template parse errors:\n${errorString}`);
    }
	//æ¨¡æ¿å…ƒæ•°æ®çš„æ ·å¼styles
    const templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata(
        {styles: prenormData.styles, moduleUrl: prenormData.moduleUrl}));
	//æ¨¡æ¿è®¿é—®è€…å®ä¾‹ã€é™„å½•TemplatePreparseVisitorã€‘
    const visitor = new TemplatePreparseVisitor();
      //é™„å½•ã€visitAllã€‘å¾ªç¯å¤„ç†rootNodes
    html.visitAll(visitor, rootNodesAndErrors.rootNodes);
    const templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata(
        {styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl}));

    const styles = templateMetadataStyles.styles.concat(templateStyles.styles);

    const inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
    const styleUrls = this
                          ._normalizeStylesheet(new CompileStylesheetMetadata(
                              {styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl}))
                          .styleUrls;
    return {
      template,
      templateUrl: templateAbsUrl,
      isInline,
      htmlAst: rootNodesAndErrors,//èŠ‚ç‚¹æ•°ç»„ã€é™„å½•HtmlParserã€‘
      styles,
      inlineStyleUrls,
      styleUrls,
      ngContentSelectors: visitor.ngContentSelectors,
    };
  }
```

##### 2-_normalizeTemplateMetadata

```typescript
@params prenormData
@params preparsedTemplate:ã€1.1è¿”å›å€¼ã€‘  

private _normalizeTemplateMetadata(
      prenormData: PrenormalizedTemplateMetadata,
      preparsedTemplate: PreparsedTemplate): SyncAsync<CompileTemplateMetadata> {
    return SyncAsync.then(
        this._loadMissingExternalStylesheets(
            preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)),
        (externalStylesheets) => this._normalizeLoadedTemplateMetadata(
            prenormData, preparsedTemplate, externalStylesheets));
  }
è¿”å›ï¼š
return new CompileTemplateMetadata({
      encapsulation,
      template: preparsedTemplate.template,
      templateUrl: preparsedTemplate.templateUrl,
      htmlAst: preparsedTemplate.htmlAst,
      styles,
      styleUrls,
      ngContentSelectors: preparsedTemplate.ngContentSelectors,
      animations: prenormData.animations,
      interpolation: prenormData.interpolation,
      isInline: preparsedTemplate.isInline,
      externalStylesheets,
      preserveWhitespaces: preserveWhitespacesDefault(
          prenormData.preserveWhitespaces, this._config.preserveWhitespaces),
    });
} 
```



### é™„å½•

#### templateSourceUrl

```typescript
export function templateSourceUrl(
    ngModuleType: CompileIdentifierMetadata, compMeta: {type: CompileIdentifierMetadata},
    templateMeta: {isInline: boolean, templateUrl: string|null}) {
  let url: string;
  if (templateMeta.isInline) {
    if (compMeta.type.reference instanceof StaticSymbol) {
      // Note: a .ts file might contain multiple components with inline templates,
      // so we need to give them unique urls, as these will be used for sourcemaps.
      url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;
    } else {
      url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;
    }
  } else {
    url = templateMeta.templateUrl!;
  }
  return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);
}
function jitSourceUrl(url: string) {
  // Note: We need 3 "/" so that ng shows up as a separate domain
  // in the chrome dev tools.
  return url.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, 'ng:///');
}
`å¦‚æœæ˜¯è¡Œå†…template`ç”Ÿæˆ urlï¼š`æ¨¡å—åç§°/ç»„ä»¶åç§°.html`  
`å¦‚æœæ˜¯templateUrl`ç”Ÿæˆ urlï¼š`è·¯å¾„/ç»„ä»¶åç§°.html`    
    --æœ€ç»ˆè½¬æ¢è¿”å›->
       `ng:///æ¨¡å—åç§°/ç»„ä»¶åç§°.html`  
```

#### HtmlParserã€htmlè§£æå™¨ã€‘

```typescript
export class HtmlParser extends Parser {
  constructor() {
    super(getHtmlTagDefinition);
  }

  parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {
    return super.parse(source, url, options);
  }
}
`è°ƒç”¨ParserğŸ‘‡`
```

#### Parserã€è§£æå™¨ã€‘

```typescript
export class Parser {
  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}

  parse(source: string, url: string, options?: lex.TokenizeOptions): ParseTreeResult {
    const tokenizeResult = lex.tokenize(source, url, this.getTagDefinition, options);ã€ğŸ‘‡è¿”å›å€¼ã€‘
    //è¿”å›_TreeBuilderå®ä¾‹
    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);ã€ğŸ‘‡_TreeBuilderã€‘
    //ç”ŸæˆèŠ‚ç‚¹æ ‘
    parser.build();
      //å®ä¾‹åŒ–{rootNodes}
    return new ParseTreeResult(
        parser.rootNodes,
        (tokenizeResult.errors as ParseError[]).concat(parser.errors),
    );
  }
}
```

#### lex

##### tokenize

```typescript
@params source:ç»„ä»¶templateå±æ€§
@params url:ç”Ÿæˆçš„åç§°
export function tokenize(
    source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition,
    options: TokenizeOptions = {}): TokenizeResult {
  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
  tokenizer.tokenize();//ã€_TokenizerğŸ‘‡ã€‘è§£ætemplate ç”Ÿæˆtokenå­˜å…¥tokens
    //ç”Ÿæˆå‚¨å­˜ tokensçš„å®ä¾‹
  return new TokenizeResult(
      mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
}

export class ParseSourceFile {
  constructor(public content: string, public url: string) {}
}
å‚æ•°1ï¼š{
    contentï¼šç»„ä»¶templateå†…å®¹,
    urlï¼šç”Ÿæˆçš„url
}
`ğŸ‘‡`
`æœ€ç»ˆè¿”å›`ï¼š{
    tokens: è§£ææ¨¡æ¿ç”Ÿæˆçš„tokens 
    errors: TokenError[],
    nonNormalizedIcuExpressions: Token[]) {}
}
```

##### _Tokenizerã€å­˜å‚¨ç”Ÿæˆçš„token,å½“å‰tokenç§ç±»ï¼Œå…‰æ ‡çŠ¶æ€ã€‘

```typescript
`_cursor`:å…‰æ ‡ä¿¡æ¯ã€å½“å‰å…‰æ ‡ASCâ…¡,è¡Œï¼Œåˆ—ã€‘

class _Tokenizer {
  private _cursor: CharacterCursor;
    //ç¼–è¯‘æ—¶çš„é…ç½®
  private _tokenizeIcu: boolean;
  private _interpolationConfig: InterpolationConfig;         //æ’å€¼è¡¨è¾¾å¼çš„ç¬¦å·
  private _leadingTriviaCodePoints: number[]|undefined;
    
  private _currentTokenStart: CharacterCursor|null = null;   //å½“å‰å…‰æ ‡çš„çŠ¶æ€
  private _currentTokenType: TokenType|null = null;          //å½“å‰tokenå…‰æ ‡çš„ç±»å‹
  private _expansionCaseStack: TokenType[] = [];
  private _inInterpolation: boolean = false;
  private readonly _preserveLineEndings: boolean;
  private readonly _escapedString: boolean;
  private readonly _i18nNormalizeLineEndingsInICUs: boolean;
  tokens: Token[] = [];                                     //å­˜å‚¨ç”Ÿæˆçš„token
  errors: TokenError[] = []; 
  nonNormalizedIcuExpressions: Token[] = [];
    
  constructor(
      _file: ParseSourceFile, private _getTagDefinition: (tagName: string) => TagDefinition,
      options: TokenizeOptions) {
    this._tokenizeIcu = options.tokenizeExpansionForms || false;
    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
          //é»˜è®¤ undefined
    this._leadingTriviaCodePoints =
        options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);
          //template å­—ç¬¦ä¸²çš„ä¿¡æ¯
    const range =
        options.range || {endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0};
          //æ ¹æ®æ˜¯å¦è½¬ä¹‰å­—ç¬¦ä¸² ç”Ÿæˆå­—ç¬¦å…‰æ ‡ã€PlainCharacterCursorã€‘
    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :
                                          new PlainCharacterCursor(_file, range);
          //æ˜¯å¦ ä¿ç•™è¡Œå°¾
    this._preserveLineEndings = options.preserveLineEndings || false;
           //æ˜¯å¦è½¬ä¹‰å­—ç¬¦ä¸²
    this._escapedString = options.escapedString || false;
          //i18nè§„èŒƒè¡Œå°¾
    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
    try {
      this._cursor.init();
    } catch (e) {
      this.handleError(e);
    }
  }
  tokenize(): void {
    while (this._cursor.peek() !== chars.$EOF) {//peekä¸º0,æ¨¡æ¿è§£æç»“æŸ
      const start = this._cursor.clone();       //ç”Ÿæˆæ–°çš„PlainCharacterCursorå®ä¾‹å‚¨å­˜ç¼–è¯‘ä¿¡æ¯ã€ifé€»è¾‘ã€‘
      try {
        if (this._attemptCharCode(chars.$LT)) {               //<
          if (this._attemptCharCode(chars.$BANG)) {             //<!
            if (this._attemptCharCode(chars.$LBRACKET)) {         //<![
              this._consumeCdata(start);
            } else if (this._attemptCharCode(chars.$MINUS)) {     //<!-
              this._consumeComment(start);          
            } else {                                            //<!Doctype                       
              this._consumeDocType(start);
            }
          } else if (this._attemptCharCode(chars.$SLASH)) {    //</        
            this._consumeTagClose(start);
          } else {
            this._consumeTagOpen(start);                       //<
          }
        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
          this._consumeText();
        }
      } catch (e) {
        this.handleError(e);
      }
    }
    this._beginToken(TokenType.EOF);
    this._endToken([]);
  }
}
`å¤„ç† CDATAæ•°æ®`:<![CDATA[æ–‡æœ¬å†…å®¹]]>
 private _consumeCdata(start: CharacterCursor) {
    this._beginToken(TokenType.CDATA_START, start);
    this._requireStr('CDATA[');
    this._endToken([]);
    this._consumeRawText(false, () => this._attemptStr(']]>'));
    this._beginToken(TokenType.CDATA_END);
    this._requireStr(']]>');
    this._endToken([]);
  }
`å¤„ç†æ³¨é‡Š`:<!--å†…å®¹-->
private _consumeComment(start: CharacterCursor) {
    this._beginToken(TokenType.COMMENT_START, start);
    this._requireCharCode(chars.$MINUS);
    this._endToken([]);
    this._consumeRawText(false, () => this._attemptStr('-->'));
    this._beginToken(TokenType.COMMENT_END);
    this._requireStr('-->');
    this._endToken([]);
  }
`å¤„ç†Doctype`:<!Doctype>
private _consumeDocType(start: CharacterCursor) {
    this._beginToken(TokenType.DOC_TYPE, start);
    const contentStart = this._cursor.clone();
    this._attemptUntilChar(chars.$GT);
    const content = this._cursor.getChars(contentStart);
    this._cursor.advance();
    this._endToken([content]);
  }
`å¤„ç†é—­åˆæ ‡ç­¾`:</tag>
private _consumeTagClose(start: CharacterCursor) {
    this._beginToken(TokenType.TAG_CLOSE, start);
    this._attemptCharCodeUntilFn(isNotWhitespace);
    const prefixAndName = this._consumePrefixAndName();
    this._attemptCharCodeUntilFn(isNotWhitespace);
    this._requireCharCode(chars.$GT);
    this._endToken(prefixAndName);
  }
`å¤„ç†å¼€å§‹æ ‡ç­¾`:<tag>
 private _consumeTagOpen(start: CharacterCursor) {
    let tagName: string;
    let prefix: string;
    let openTagToken: Token|undefined;
    try {
      if (!chars.isAsciiLetter(this._cursor.peek())) {
        throw this._createError(
            _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
      }

      openTagToken = this._consumeTagOpenStart(start);
      prefix = openTagToken.parts[0];
      tagName = openTagToken.parts[1];
      this._attemptCharCodeUntilFn(isNotWhitespace);
      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT &&
             this._cursor.peek() !== chars.$LT) {
        this._consumeAttributeName();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        if (this._attemptCharCode(chars.$EQ)) {
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._consumeAttributeValue();
        }
        this._attemptCharCodeUntilFn(isNotWhitespace);
      }
      this._consumeTagOpenEnd();
    } catch (e) {
      if (e instanceof _ControlFlowError) {
        if (openTagToken) {
          // We errored before we could close the opening tag, so it is incomplete.
          openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;
        } else {
          // When the start tag is invalid, assume we want a "<" as text.
          // Back to back text tokens are merged at the end.
          this._beginToken(TokenType.TEXT, start);
          this._endToken(['<']);
        }
        return;
      }

      throw e;
    }

    const contentTokenType = this._getTagDefinition(tagName).contentType;

    if (contentTokenType === TagContentType.RAW_TEXT) {
      this._consumeRawTextWithTagClose(prefix, tagName, false);
    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
      this._consumeRawTextWithTagClose(prefix, tagName, true);
    }
  }
`å¤„ç†æ–‡æœ¬`
private _consumeText() {
    const start = this._cursor.clone();
    this._beginToken(TokenType.TEXT, start);
    const parts: string[] = [];

    do {
      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
        parts.push(this._interpolationConfig.start);
        this._inInterpolation = true;
      } else if (
          this._interpolationConfig && this._inInterpolation &&
          this._attemptStr(this._interpolationConfig.end)) {
        parts.push(this._interpolationConfig.end);
        this._inInterpolation = false;
      } else {
        parts.push(this._readChar(true));
      }
    } while (!this._isTextEnd());

    this._endToken([this._processCarriageReturns(parts.join(''))]);
  }
```

##### æ¨¡æ¿è§£æå‡½æ•°

###### _beginToken

```typescript
@params type:æ ‡è®°å½“å‰ç”Ÿæˆtokençš„ç±»å‹
@params start:å½“å‰å…‰æ ‡å®ä¾‹ã€å­˜å‚¨ç¼–è¯‘çŠ¶æ€ã€‘

private _beginToken(type: TokenType, start = this._cursor.clone()) {
    this._currentTokenStart = start;
    this._currentTokenType = type;
  }
`è·å– å½“å‰tokençš„å…¶å®çŠ¶æ€å’Œç±»å‹ã€‚`
```

###### _requireStr

```typescript
  private _requireStr(chars: string) {
    const location = this._cursor.clone();
    if (!this._attemptStr(chars)) {
      throw this._createError(
          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
    }
  }
```

###### _attemptStr

```typescript
@params chars:æœŸæœ›å¾—åˆ°çš„å­—ç¬¦ä¸²

private _attemptStr(chars: string): boolean {
    const len = chars.length;
    if (this._cursor.charsLeft() < len) {
      return false;
    }
    const initialPosition = this._cursor.clone();
    for (let i = 0; i < len; i++) {
      if (!this._attemptCharCode(chars.charCodeAt(i))) {
        // If attempting to parse the string fails, we want to reset the parser
        // to where it was before the attempt
        this._cursor = initialPosition;
        return false;
      }
    }
    return true;
  }
`å°†æœŸæœ›å¾—åˆ°çš„å­—ç¬¦ä¸²å’Œç°æœ‰çš„å­—ç¬¦ä¸²é€ä¸ªæ¯”è¾ƒï¼Œå¦‚æœç›¸åŒè¿”å›trueï¼Œä¸ç›¸åŒå°±è¿”å›falseï¼Œé€€åˆ°åŸå§‹çŠ¶æ€ã€‚ğŸ‘‡`
```

###### _attemptCharCode

```typescript
  private _attemptCharCode(charCode: number): boolean {
    if (this._cursor.peek() === charCode) {
      this._cursor.advance();
      return true;
    }
    return false;
  }
```

###### advance

```typescript
 advance(): void {
    this.advanceState(this.state);
  }
è°ƒç”¨ğŸ‘‡æ›´æ”¹çŠ¶æ€ã€‚  
```

###### advanceState

```typescript
protected advanceState(state: CursorState) {
    if (state.offset >= this.end) {
      this.state = state;
      throw new CursorError('Unexpected character "EOF"', this);
    }
    const currentChar = this.charAt(state.offset);
    if (currentChar === chars.$LF) {//é‡åˆ°æ¢è¡Œç¬¦å°± è¡Œ+1,åˆ—ä¸å˜
      state.line++;
      state.column = 0;
    } else if (!chars.isNewLine(currentChar)) {//éæ¢è¡Œï¼Œåˆ—ï¼‹1
      state.column++;
    }
    state.offset++;   //å…‰æ ‡å³ç§»1ä½
    this.updatePeek(state); //æ›´æ–°å½“å‰å…‰æ ‡å­—ç¬¦
  }
`æ›´æ–° _cursorä¿¡æ¯`
```

###### _endToken

```typescript
  private _endToken(parts: string[], end?: CharacterCursor): Token {
    if (this._currentTokenStart === null) {
      throw new TokenError(
          'Programming error - attempted to end a token when there was no start to the token',
          this._currentTokenType, this._cursor.getSpan(end));
    }
    if (this._currentTokenType === null) {
      throw new TokenError(
          'Programming error - attempted to end a token which has no token type', null,
          this._cursor.getSpan(this._currentTokenStart));
    }
    const token = new Token(
        this._currentTokenType, parts,
        this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
    this.tokens.push(token);
    this._currentTokenStart = null;
    this._currentTokenType = null;
    return token;
  }
`getSpan`
`ç”Ÿæˆtoken`ğŸ‘‡
åˆå§‹åŒ–æ•°æ®
è¿”å›token
```

###### getSpanã€PlainCharacterCursorã€‘

```typescript
@params startï¼šè§£ætokenæ—¶çš„åˆå§‹çŠ¶æ€ã€æ˜¯åˆå§‹_cursorã€‘
@params thisï¼š_cursorã€æ›´æ–°åçš„cursorã€‘

getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan {
    start = start || this;
    let fullStart = start;
      //é»˜è®¤ä¸º undefined
    if (leadingTriviaCodePoints) {
      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
        if (fullStart === start) {
          start = start.clone() as this;
        }
        start.advance();
      }
    }
    const startLocation = this.locationFromCursor(start);//å…³äºæœ¬tokenèµ·ç‚¹çš„ä¿¡æ¯ğŸ‘‡
    const endLocation = this.locationFromCursor(this);////å…³äºæœ¬tokenç»ˆç‚¹çš„ä¿¡æ¯ğŸ‘‡
    const fullStartLocation =
        fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);
  }
ç”Ÿæˆ ParseSourceSpanå®ä¾‹ å‚æ•°æ˜¯locationFromCursorè¿”å›å€¼
```

###### Tokenã€ä¿å­˜åœ¨tokensä¸­çš„æ•°æ®ã€‘

```typescript
export class Token {
  constructor(
      public type: TokenType|null, public parts: string[], public sourceSpan: ParseSourceSpan) {}
}
`è¿”å›`{
    type:tokenç±»å‹ã€å¼€å§‹æ ‡ç­¾/é—­åˆæ ‡ç­¾/doctype/æ³¨é‡Š...ã€‘
    parts:ä¼ å…¥çš„æ•°æ® string[]
    sourceSpanï¼šParseSourceSpanå®ä¾‹ğŸ‘‡
}
```



###### ParseSourceSpan

```typescript
class ParseSourceSpan {
      constructor(
      public start: ParseLocation, public end: ParseLocation,
      public fullStart: ParseLocation = start, public details: string|null = null) {}
}
è¿”å›ï¼š{
    start: _cursorã€tokenåˆå§‹cursoræ•°æ®ã€‘, 
    end: _cursorã€tokenç»“æŸcursoræ•°æ®ã€‘,
    fullStart: _cursor, 
    details: null
}
_cursor:PlainCharacterCursorå®ä¾‹
```



###### locationFromCursor

```typescript
  private locationFromCursor(cursor: this): ParseLocation {
    return new ParseLocation(
        cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
  }
class ParseLocation {
  constructor(
      public file: ParseSourceFile, public offset: number, public line: number,
      public col: number) {}
}
`ç”Ÿæˆ ParseLocationå®ä¾‹`:{
    file:{content:æ¨¡æ¿å†…å®¹,url:ç”Ÿæˆçš„htmlæ–‡ä»¶å},
    offset: æ¨¡æ¿èµ·ç‚¹,
    line:è¡Œæ•°,  
    col:åˆ—æ•°,
}
```

###### _consumeTagOpenã€å¤„ç†å¼€å§‹æ ‡ç­¾ã€‘

```typescript
  private _consumeTagOpen(start: CharacterCursor) {
    let tagName: string;
    let prefix: string;
    let openTagToken: Token|undefined;
    try {
      `tagå¦‚æœä¸æ˜¯å¤§å°å†™å­—æ¯å¼€å¤´ æŠ¥é”™`
	  //å­˜å‚¨å¼€å§‹æ ‡ç­¾tokenï¼Œprefixæ˜¯tagå‰ç¼€ã€ä¸€èˆ¬ä¸ºç©ºã€‘,tagNameæ˜¯æ ‡ç­¾å
      openTagToken = this._consumeTagOpenStart(start);
        //è·å–å‰ç¼€å’Œæ ‡ç­¾åç§°
      prefix = openTagToken.parts[0];
      tagName = openTagToken.parts[1];
      this._attemptCharCodeUntilFn(isNotWhitespace);
        //å¾ªç¯è§£æå¼€å§‹æ ‡ç­¾ä¸­çš„å±æ€§
      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT &&
             this._cursor.peek() !== chars.$LT) {
          //å±æ€§åç§°
        this._consumeAttributeName();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        if (this._attemptCharCode(chars.$EQ)) {
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._consumeAttributeValue();
        }
        this._attemptCharCodeUntilFn(isNotWhitespace);
      }
        //è§£æå®Œæˆå±æ€§å,è§£æé—­åˆæ ‡ç­¾
      this._consumeTagOpenEnd();
    } catch (e) {
      if (e instanceof _ControlFlowError) {
        if (openTagToken) {
          // We errored before we could close the opening tag, so it is incomplete.
          openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;
        } else {
          // When the start tag is invalid, assume we want a "<" as text.
          // Back to back text tokens are merged at the end.
          this._beginToken(TokenType.TEXT, start);
          this._endToken(['<']);
        }
        return;
      }

      throw e;
    }
	//æ ¹æ®æ ‡ç­¾åè·å–å¯¹åº”çš„htmlå®šä¹‰ã€_getTagDefinitionæ˜¯æ˜ å°„è¡¨<tag->å®šä¹‰>ã€‘
    const contentTokenType = this._getTagDefinition(tagName).contentType;//è¿”å›æ ‡ç­¾ç±»å‹ é»˜è®¤æ˜¯2ã€å¯åˆ†ææ•°æ®ï¼Ÿã€‘

    if (contentTokenType === TagContentType.RAW_TEXT) {//RAW_TEXTæ˜¯åŸå§‹æ–‡æœ¬ï¼Ÿï¼Ÿï¼Ÿ
      this._consumeRawTextWithTagClose(prefix, tagName, false);
    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {//RAW_TEXTæ˜¯åŸå§‹æ–‡æœ¬ï¼Ÿï¼Ÿï¼Ÿ
      this._consumeRawTextWithTagClose(prefix, tagName, true);
    }
  }
```

###### _consumeTagOpenStart

```typescript
  private _consumeTagOpenStart(start: CharacterCursor) {
    this._beginToken(TokenType.TAG_OPEN_START, start);
    const parts = this._consumePrefixAndName();
    return this._endToken(parts);
  }
```

###### _consumePrefixAndName

```typescript
  private _consumePrefixAndName(): string[] {
    const nameOrPrefixStart = this._cursor.clone();
    let prefix: string = '';
    while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {//éå†’å·ä¸”åœ¨a-zA-Z0-9
      this._cursor.advance();
    }
    let nameStart: CharacterCursor;
    if (this._cursor.peek() === chars.$COLON) {
      prefix = this._cursor.getChars(nameOrPrefixStart);
      this._cursor.advance();
      nameStart = this._cursor.clone();
    } else {
      nameStart = nameOrPrefixStart;
    }
    this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);
    const name = this._cursor.getChars(nameStart);
    return [prefix, name];
  }
prefix:å‰ç¼€
name:åç§°
```



##### PlainCharacterCursorã€å­˜å‚¨templateä¿¡æ¯çš„ä¸»è¦å‡½æ•°ã€‘

```typescript
`ç»„ä»¶æœ‰ templateå±æ€§`
@params fileOrCursor:tokenizeè¿”å›å€¼
@params range:_Tokenizerçš„range

`ã€åˆå§‹èµ°elseã€‘`
`ã€åœ¨è§£æè¿‡ç¨‹ä¸­clone æ—¶èµ° if ã€‘`

class PlainCharacterCursor implements CharacterCursor {
    constructor(fileOrCursor: ParseSourceFile|PlainCharacterCursor, range?: LexerRange) {
    if (fileOrCursor instanceof PlainCharacterCursor) {
      this.file = fileOrCursor.file;
      this.input = fileOrCursor.input;
      this.end = fileOrCursor.end;

      const state = fileOrCursor.state;
      // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.
      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which
      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is
      // called in tight loops, this difference matters.
      this.state = {
        peek: state.peek,
        offset: state.offset,
        line: state.line,
        column: state.column,
      };
    } else {
      if (!range) {
        throw new Error(
            'Programming error: the range argument must be provided with a file argument.');
      }
      this.file = fileOrCursor;ã€{content:templateå†…å®¹, url:æ–‡ä»¶å}ã€‘
      this.input = fileOrCursor.content;ã€template æ¨¡æ¿å†…å®¹ã€‘
      this.end = range.endPos;ã€template æ¨¡æ¿ çš„é•¿åº¦ã€‘
      //åˆå§‹åŒ–ï¼Œè®°å½•ç¼–è¯‘çŠ¶æ€
      this.state = {
        peek: -1,ã€è®°å½•å½“å‰å…‰æ ‡ç‚¹çš„ ASCâ…¡ å€¼, -1ä¸ºåˆå§‹åŒ–æ ‡å¿—,0ä¸ºç»“æŸæ ‡å¿—,ä¸­é—´çŠ¶æ€ä¸ºå…‰æ ‡ç‚¹çš„ASCâ…¡ å€¼ã€‘
        offset: range.startPos,ã€å½“å‰å…‰æ ‡ä½ç½®ã€‘
        line: range.startLine,ã€å½“å‰è¡Œã€‘
        column: range.startCol,ã€å½“å‰åˆ—ã€‘
      };
    }
  }
  clone(): PlainCharacterCursor {
    return new PlainCharacterCursor(this);
  }
  init(): void {
    this.updatePeek(this.state);
  }
  protected updatePeek(state: CursorState): void {
      //æ”¹å˜çŠ¶æ€ä¸­çš„peek, -1ä¸ºåˆå§‹åŒ–æ ‡å¿—,0ä¸ºç»“æŸæ ‡å¿—,ä¸­é—´çŠ¶æ€ä¸ºå…‰æ ‡ç‚¹çš„ASCâ…¡ å€¼
    state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);
  }
 getChars(start: this): string {
    return this.input.substring(start.state.offset, this.state.offset);
  }
}
`è¿”å›å…‰æ ‡æ•°æ®`
----â€˜ä¸å˜æ•°æ®â€™
this.file:{content:templateå†…å®¹, url:æ–‡ä»¶å}
this.input:ã€template æ¨¡æ¿å†…å®¹ã€‘
this.end:ã€template æ¨¡æ¿ çš„é•¿åº¦ã€‘

-----â€˜å˜åŠ¨æ•°æ®â€™
this.state:{
    peek: -1,ã€è®°å½•å½“å‰å…‰æ ‡ç‚¹çš„ ASCâ…¡ å€¼, -1ä¸ºåˆå§‹åŒ–æ ‡å¿—,0ä¸ºç»“æŸæ ‡å¿—,ä¸­é—´çŠ¶æ€ä¸ºå…‰æ ‡ç‚¹çš„ASCâ…¡ å€¼ã€‘
        offset: range.startPos,ã€å½“å‰å…‰æ ‡ä½ç½®ã€‘
        line: range.startLine,ã€å½“å‰è¡Œã€‘
        column: range.startCol,ã€å½“å‰åˆ—ã€‘
}
```

#### _TreeBuilder

```typescript
class _TreeBuilder {
  private _index: number = -1;
  // `_peek` will be initialized by the call to `advance()` in the constructor.
  private _peek!: lex.Token;
  private _elementStack: html.Element[] = [];

  rootNodes: html.Node[] = [];
  errors: TreeError[] = [];

  constructor(
      private tokens: lex.Token[], private getTagDefinition: (tagName: string) => TagDefinition) {
    this._advance();
  }
  private _advance(): lex.Token {
    const prev = this._peek;
    if (this._index < this.tokens.length - 1) {
      // Note: there is always an EOF token at the end
      this._index++;
    }
    this._peek = this.tokens[this._index];
    return prev;
  }
  build(): void {
    while (this._peek.type !== lex.TokenType.EOF) {
      if (this._peek.type === lex.TokenType.TAG_OPEN_START ||
          this._peek.type === lex.TokenType.INCOMPLETE_TAG_OPEN) {
        this._consumeStartTag(this._advance());
      } else if (this._peek.type === lex.TokenType.TAG_CLOSE) {
        this._consumeEndTag(this._advance());
      } else if (this._peek.type === lex.TokenType.CDATA_START) {
        this._closeVoidElement();
        this._consumeCdata(this._advance());
      } else if (this._peek.type === lex.TokenType.COMMENT_START) {
        this._closeVoidElement();
        this._consumeComment(this._advance());
      } else if (
          this._peek.type === lex.TokenType.TEXT || this._peek.type === lex.TokenType.RAW_TEXT ||
          this._peek.type === lex.TokenType.ESCAPABLE_RAW_TEXT) {
        this._closeVoidElement();
        this._consumeText(this._advance());
      } else if (this._peek.type === lex.TokenType.EXPANSION_FORM_START) {
        this._consumeExpansion(this._advance());
      } else {
        // Skip all other tokens...
        this._advance();
      }
    }
  }
}
`å°†åˆå¹¶çš„tokenæ”¾åˆ° _elementStack `
```

#### TemplatePreparseVisitorã€2ã€‘

```typescript
class TemplatePreparseVisitor implements html.Visitor {
  ngContentSelectors: string[] = [];
  styles: string[] = [];
  styleUrls: string[] = [];
  ngNonBindableStackCount: number = 0;

  visitElement(ast: html.Element, context: any): any {
    const preparsedElement = preparseElement(ast);
    switch (preparsedElement.type) {
      case PreparsedElementType.NG_CONTENT:
        if (this.ngNonBindableStackCount === 0) {
          this.ngContentSelectors.push(preparsedElement.selectAttr);
        }
        break;
      case PreparsedElementType.STYLE:
        let textContent = '';
        ast.children.forEach(child => {
          if (child instanceof html.Text) {
            textContent += child.value;
          }
        });
        this.styles.push(textContent);
        break;
      case PreparsedElementType.STYLESHEET:
        this.styleUrls.push(preparsedElement.hrefAttr);
        break;
      default:
        break;
    }
    if (preparsedElement.nonBindable) {
      this.ngNonBindableStackCount++;
    }
    html.visitAll(this, ast.children);
    if (preparsedElement.nonBindable) {
      this.ngNonBindableStackCount--;
    }
    return null;
  }

  visitExpansion(ast: html.Expansion, context: any): any {
    html.visitAll(this, ast.cases);
  }

  visitExpansionCase(ast: html.ExpansionCase, context: any): any {
    html.visitAll(this, ast.expression);
  }

  visitComment(ast: html.Comment, context: any): any {
    return null;
  }
  visitAttribute(ast: html.Attribute, context: any): any {
    return null;
  }
  visitText(ast: html.Text, context: any): any {
    return null;
  }
}
```

#### visitAllã€2ã€‘

```typescript
`å¾ªç¯å¤„ç†ç”Ÿæˆçš„èŠ‚ç‚¹`
visitor.visit:undefined;
nodes:Elementå®ä¾‹ğŸ‘‡
content:null

export function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {
  const result: any[] = [];

  const visit = visitor.visit ?
      (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context) :
      (ast: Node) => ast.visit(visitor, context);
  nodes.forEach(ast => {
    const astResult = visit(ast);
    if (astResult) {
      result.push(astResult);
    }
  });
  return result;
}

```

##### Elementã€2ã€‘

```typescript
export class Element extends NodeWithI18n {
  constructor(
      public name: string, public attrs: Attribute[], public children: Node[],
      sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,
      public endSourceSpan: ParseSourceSpan|null = null, i18n?: I18nMeta) {
    super(sourceSpan, i18n);
  }
  visit(visitor: Visitor, context: any): any {
    return visitor.visitElement(this, context);
  }
}
`è°ƒç”¨TemplatePreparseVisitor ä¸­çš„ visitElement å¾€visitorå‚¨å­˜æ•°æ®` åœ¨è°ƒç”¨è¿‡ç¨‹ä¸­ï¼Œä¸æ–­åœ°è°ƒç”¨childï¼Œå¤„ç†æ‰€æœ‰èŠ‚ç‚¹ã€‚
```

