# CompilerFacadeImpl

```typescript
`编译器的容器`：内部包含【管道编译，注入编译，模块编译，指令编译，组件编译等函数】
`compileComponent`:组件编译

AppComponent的编译结果：'./编译结果文件/AppComponent.js'
```

## compileComponent

`组件编译[jit模式下]`

```typescript
组件的编译是在 `ɵcmp[ngComponentDef]` 的 get阶段。编译过程如下：
`1.`template:模板子字符串
`2.`tokenize:通过配置[插值语法，无效字符表，空格字符是否保留,....]解析template生成 token表
`3.`_TreeBuilder：根据tokens,将节点处理成ast，去除无效节点[合并空白节点，去除'\n'] 
`4.`htmlAstToRender3Ast:处理节点的ng特殊属性[传输值，绑定事件，特殊节点[‘ng-template’],指令等]
	 Element/Template节点：'[prop]':存入inputs属性中; '(eventName)':存入outputs中; '#标记名'：存入references中
     		  '普通属性'：存入attributes中; '子节点'：存入children
     Template节点：'let-name'：声明属性存入 variables; 
                 'ngTemplateOutlet' 和 'ngTemplateOutletContext'存入 templateAttrs
`5.`BindingParser: 解析模板和指令宿主区域中的绑定,将NgComponentDef所需的template数据进行token转换，最终转换成Expression 
`6.`definitionMap: 会解析 NgComponentDef 的 组件基础数据解析成Expression与上一步解析模板的表达式合并
`7.`jitExpression：将组件基础Expression和组件模板Expression 合并转换成 代码输出【NgComponentDef】。
```

`2.`tokenize模板解析

```typescript
`通过ASCII 对比 解析【<tag, <--, <![, </tag】`
tokens：token集合🧩
_currentTokenStart：当前token的其实状态
_currentTokenType：当前token 的类型【开始标签，text，闭合标签，注释,....】
_inInterpolation：标记当前解析是否在插值语法【{{}}】内
end:记录template 的长度
state:{
    column:3     //当前列
    line:0       //当前行    遇到 [\n] 增加
    offset:3     //当前位置
    peek:105     //当前字符的 ASCII值  peek == $EOF 【offset >= end】 时 结束
}
advance函数，更新state，不断推进offset。

根据类别生成token:{
    type：token的类型，【开始标签，闭合标签,....】
    parts：【关键字段，比如[tag前缀，tag],】
    sourceSpan：记录token的坐标[行，列，第几个字符]及 所属文件uri和总模板内容content
}

---开始标签---
<tagname，解析到标签后，继续尝试解析属性【直到遇到['>','/','<']】，将解析的属性token 放入tokens中

---闭合标签----
遇到'/' + 'tagname' + '>';生成闭合标签的token； 

---text----
遇到text，需要考虑插值语法：{{}}，遇到'{{'进行标记[_inInterpolation],再去尝试'}}'
text的结束标志判断：遇到'<',结束text，再继续判断

`tokenize` 只是将标签 和属性进行分离解析。
```

`3.`_TreeBuilder

```typescript
`通过tokens中的标记，建立层级节点关系树🎄`
tokens：tokenize 的解析结果。
_index：tokens的标志位，标记当前解析token
_elementStack：节点栈，处理节点关系。
rootNodes：保存根节点

处理过程：将attribute token 合并到 <开始节点>token，清除'\n'，合并多空白字符，将子节点合并到父节点的children中
```

`4.`htmlAstToRender3Ast

```typescript
`将解析的普通ast节点，转换为ivy要使用的格式【对于特殊属性[指令],特殊tag的标记,插值语法】`:实际是对于ng语法的标记

`---预解析--------`
节点属性：['select','href','rel','ngNonBindable','ngProjectAs']
          'select':select 为空就会被设置为'*'
节点类型:['NG_CONTENT','STYLE','STYLESHEET','SCRIPT','OTHER']
		 'STYLESHEET': <link rel="stylesheet">
通过预解析，确定节点类型，再策略处理。             
             
`--text---`
1-查找‘{{}}’,
2-如果有插值语法，再查找 pipe
根据text是否是动态【插值语法,pipe】的生成不同的实例【Text,BoundText】
对于Text，在下一阶段会只生成creationInstruction
对于BoundText,在下一阶段会生成creationInstruction 和 updateInstructionWithAdvance


`--节点----`
Element{
    children: 子节点
    attributes: 节点属性
    references: #name 会被放入【存放标记的地方】
    outputs:  绑定的事件
    name:'div'
    inputs: 输入属性：【被[]包裹的属性】
    i18n:
    ParseSourceSpan： 源文件的记录
    souceSpan：源文件的记录
    endSourceSpan: 节点结束位置的记录
    
}

`---ng-container---`
解析 'ngTemplateOutlet' 和 'ngTemplateOutletContext'两个 BoundAttribute

`对于模板类型，会创造一个template 将自身节点包裹`

Template{
        tagName, 
        attributes, 
        inputs, 
        outputs, 
        templateAttrs,  //存储 模板属性【BoundAttribute】
        children, 这个children 就是被包裹的【ng-container节点】
        references, 
        variables, 
        sourceSpan, 
        startSourceSpan, 
        endSourceSpan, i18n
    
}
`---ng-template---`
也会生成 template 节点
```

`5.`BindingParser / constantPool

```typescript
`compileComponentFromMeta`:根据ast节点及指令元数据，生成更新/创建指令对应的【ast代码语句token并拼接生成template函数】。
分为两个阶段：NgComponentDef 中基础属性的【代码token】`[compileComponentFromMetadata](definitionMap中不包括
              template的代码)`
		   template模板创建/更新的【代码token】`[TemplateDefinitionBuilder ]`
例如[动态的样式,绑定的属性值,指令,.... ]。最终拼接成完整的： 【NgComponentDef】函数
template节点对应的·指令函数·[分为两个模式：创建模式,更新模式]。



根据节点的类型【Element，Template】,有不同的处理方式
`_creationCodeFns`：创建节点所用到的函数
`_updateCodeFns`:更新节点所用到的函数

`---Element节点---`
Element节点：{
    span：节点的源文件映射位置
    reference：{moduleName:'@angular/core',name:'ɵɵelementStart'}
    paramsOrFn <LiteralExpr[]>：[index,tagName,]
}
`1.`使用Element节点的数据创建指令creationInstruction[内部调用instruction(span, reference, params)]
`2.`递归处理子节点
`3.`当创建完节点 creation函数 后，同样要创建 endElement 创建函数

`---Template节点---【ng-containere,ng-template】`
Template节点：{
    
}

`---text----`
当遇到text节点时，会根据
```

`5.1` TemplateDefinitionBuilder 

```typescript
根据 node属性 生成 创建/更新指令集

创建指令集：creationInstruction
更新指令集：updateInstructionWithAdvance【包括advance[移动位置] + updateInstruction】

_constants:{constExpressions:节点属性【.constsNgComponentDef.consts】,prepareStatements:}
_creationCodeFns：创建创建指令集函数的代码token存储位置【根据指令index，tag，属性index创建Element节点】
_updateCodeFns：创建更新指令集函数的代码token存储位置【根据指令index，tag，属性index更新Element节点】
_dataIndex:滚动节点的位置，在creationInstruction和updateInstructionWithAdvance时使用
			【与 NgComponentDef.decls属性相关】
_pureFunctionSlots：【与 NgComponentDef.vars属性相关】
```



### NgComponentDef

`组件的实例函数`,defineComponent的参数是 definitionMap。

```typescript

const $def = defineComponent({
        type: 组件类,
        selectors: 选择器//
        contentQueries：内容查询函数
        viewQuery: function AppComponent_Query(rf, ctx) {
            if (rf & 1) {
                jit___viewQuery_8(_c0, 1);
            }
            if (rf & 2) {
                var _t;
                jit___queryRefresh_9((_t = jit___loadQuery_10())) &&
                    (ctx.dir = _t.first);
            }
        },
        features: 与NgOnChanges生命周期有关,
        decls: 视图节点的数量,
        vars: 5,
        consts: 【数组，函数[】解析出element节点上的所有属性[
            [存储节点上的属性集合{属性的值，属性的类别}，在创建/更新时使用]
            enum type{
                class = 1;
                style = 2;
                [property] | (event) = 3
				*指令集 = 4
            }
            无type的属于其他类型[#标签,'id = value', '指令']
        ]
        template: function AppComponent_Template(rf, ctx) {
            模板的指令集，分为两种模式
            	rf == 1：创建
                rf == 2：更新
            通过调用对应指令函数，去创建/更新节点。
            创建element：elementStart(elementIndex, tagName,
                                   对应属性在consts中的index,
                                   对应索引在consts中的index,)
        },
        styles: [样式,
        ],
    })
```



#### constantPool

```typescript
常量池，收集在创建指令集<instruction>过程中的数据

statements://收集 常量代码token块,比如ContentChild，ViewChild【因为这些数据需要常量保存，区别于模板的动态数据】
pipeDefinitions:Map(0)
nextNameIndex:1
literals:Map(1) {["content"] => FixupExpression …} //收集[@ContentView],[@ViewChild]映射
literalFactories:Map(0)
isClosureCompilerEnabled:false
injectorDefinitions:Map(0)
directiveDefinitions:Map(0)
componentDefinitions:
```

#### @ContentChild()

```typescript
@ContentChild('选择符') 名称;
内容查询：在解析过程中，被 `constantPool.literals`收集映射关系；最终生成内容查询函数的代码块存入`definitionMap.contentQueries`

```

#### @ViewChild()

```typescript
@ViewChild('选择符') 名称;
视图查询：在解析过程中，被 `constantPool.literals`收集映射关系；最终生成内容查询函数的代码块存入`definitionMap.viewQuery`
```

## compileNgModuleDefs

模块编译

```
模块会编译出一个 inject静态函数。
```

# 代码token

#### DeclareVarStmt `var表达式`

```
@params name       名称
@params value      值
@params type 
@params modifiers   
@params sourceSpan 源地址
@params leadingComments
```



#### LiteralExpr`基础表达式`

```typescript
value:值
type:
sourceSpan:记录源位置
```

#### LiteralMapExpr `对象表达式`

```
@params entries：LiteralMapEntry[] 【{key,value}】 
@params type
@params sourceSpan 源地址
@params typeParams
```

#### importExpr `import外部文件`表达式

```
importExpr({模块名, 函数名称}).callFn()
importExpr 引用 ExternalExpr 构造表达式,再调用 父级 Expression 的原型，构造特定表达式 
```

#### ExternalExpr `外部引入的表达式`

```
@params value:{name:'**', moduleName:'**'} 外部引入表达式
@params sourceSpan 源地址
@params type
@params typeParams
```

#### InvokeFunctionExpr `函数表达式`

```
@params fn         函数 ExternalExpr 
@params args       参数 其他表达式【对象，数组,...】
@params type  
@params sourceSpan 源地址
@params pure
```

