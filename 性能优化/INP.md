## 一帧

  帧 是浏览器渲染的基本时间单位，通常与显示器的刷新率同步（如 60Hz =
  16.67ms/帧，144Hz =
  6.94ms/帧）。浏览器需要在每帧内完成所有渲染工作，以产生流畅的视觉体验。

  ---

## 一帧中的典型执行流程 (≈16.67ms @ 60Hz)

### 1. 输入处理
- 用户输入事件 (点击、触摸、键盘等)
- 资源加载完成事件
- 网络请求响应
- 定时器到期事件

### 2. 浏览器事件处理
- 事件捕获和冒泡阶段处理
- 确定事件目标元素和传播路径
- 准备执行对应的事件监听器

### 3. JavaScript 代码执行
- 执行一个或多个宏任务 (事件回调、定时器回调等)
- 注册新的回调到相应队列
- 清空当前宏任务产生的微任务队列 (Promise.then、MutationObserver)
- 样式修改：进入"样式脏标记"队列，不会立即触发重排
- 读取布局属性：会强制同步重排（立即在当前帧执行布局计算）
- 注意：微任务循环会导致页面卡死

### 4. requestAnimationFrame
- 执行所有注册的rAF回调(回调产生的样式修改会在下一帧体现，在当前帧不会渲染)

### 5. 样式重计算
- 重新计算受影响的元素样式
- 应用CSS动画和过渡
- 更新CSS变量和自定义属性

### 6. 布局 (重排)
- 计算元素几何属性 (位置、尺寸)
- 处理flexbox和grid布局
- 更新布局树结构

### 7. 绘制 (重绘)
- 生成绘制操作记录
- 处理canvas和SVG绘制
- 准备图层合成数据

### 8. 合成
- 图层分块和光栅化
- GPU加速合成操作
- 生成最终帧缓冲区
- 某些属性（如 transform、opacity）可以创建独立的合成层，避免触发布局和重绘，优化性能

### 9. 提交和显示
- 将帧提交到显示子系统
- VSync同步显示

### 10. 空闲时间处理
- 执行 requestIdleCallback 回调

  ---
**样式修改与重排机制详解**

**样式修改流程**：
- 修改样式属性时，浏览器标记元素为"样式脏"（dirty）状态
- 这些修改进入"样式脏标记"队列，不会立即触发重排
- 重排操作会在**当前帧的布局阶段**（第6步）统一批量处理

**处理时机**：
- 正常情况：样式脏标记在当前帧记录，在当前帧布局阶段处理
- 强制同步：读取布局属性时，立即在当前JavaScript执行上下文中处理

**强制同步重排**：
- 当读取布局属性（offsetWidth、offsetHeight、getComputedStyle等）时
- 浏览器必须立即执行所有挂起的布局计算，返回准确值
- 这会强制在当前JavaScript执行上下文中同步完成重排操作

**重排的本质**：
重排不是hook，而是浏览器渲染流水线中的一个**完整布局计算操作**，包括：
- 重新计算所有受影响元素的几何属性（位置、大小）
- 更新整个文档流的布局结构
- 这是一个相对昂贵的操作，会阻塞主线程

---
JavaScript 执行时序详解

## 执行顺序规则

1. **宏任务优先**：每个帧从执行一个宏任务开始
2. **微任务清空**：当前宏任务完成后，立即执行当前宏任务生成的所有微任务(直到清空微任务队列)
3. **rAF回调**：微任务后执行requestAnimationFrame回调(当前帧执行，修改的样式在下一帧生效)
4. **渲染阶段**：执行样式计算、布局、绘制、合成
5. **rIC回调**：渲染后如有剩余时间，执行requestIdleCallback

## 重要概念澄清

**事件循环机制详解**：

浏览器事件循环的实际机制是：

1. **取一个宏任务执行**（如事件回调、定时器回调）
2. **执行该宏任务中产生的所有微任务**（清空当前微任务队列）
3. **执行渲染流程**（如果需要渲染）
4. **执行requestIdleCallback**（如果有剩余时间）
5. **重复步骤1**，处理下一个宏任务

注意：每个宏任务完成后只清空**它自己产生的微任务**，不是清空全局所有微任务。

## 浏览器时间管理策略

浏览器使用智能的时间管理机制来平衡任务执行和渲染流畅度：

1. **动态时间预算**：
   - JavaScript执行：约10ms @ 60Hz（动态调整）
   - 渲染阶段：约5-6ms（相对固定）
   - 不是预先划分固定时间

2. **优先级机制**：
   - 用户交互事件：最高优先级（立即执行）
   - 渲染任务：中等优先级（保证60fps流畅度）
   - 后台任务：最低优先级（requestIdleCallback）

3. **中断机制**：
   - JavaScript执行超时会被中断，优先进行渲染
   - 防止长时间JS执行导致页面卡死

4. **自适应调度**：
   - 根据设备性能动态调整时间分配
   - 高性能设备执行更多任务，低性能设备优先保证渲染

  ## 多帧执行示例

  ```
  // 当前帧 (Frame N)
  console.log('Frame N: 开始');
  
  setTimeout(() => {                             // 宏任务，下一帧执行
    console.log('Frame N+1: setTimeout');
  }, 0);

  Promise.resolve().then(() => {                  // 微任务，当前帧执行
    console.log('Frame N: Promise');
  });

  requestAnimationFrame(() => {                   // rAF，当前帧执行
    console.log('Frame N: rAF回调');
    element.style.transform = 'translateX(100px)'; // 修改样式，下一帧生效
  });

  console.log('Frame N: 结束');

  // 输出顺序：
  // Frame N: 开始
  // Frame N: 结束
  // Frame N: Promise
  // Frame N: rAF回调
  // Frame N+1: setTimeout (下一帧)
  ```

  ## 关键机制说明

  | 阶段    | 作用             | 可能触发条件               |
  |-------|----------------|----------------------|
  | 输入处理  | 处理用户交互和事件分发    | 用户点击、键盘输入、滚动
  |
  | JS 执行 | 执行脚本代码、操作 DOM  | 定时器、事件回调、rAF         |
  | 样式计算  | 计算每个元素的最终样式    | 类名改变、style 属性变化      |
  | 布局    | 计算几何信息（位置、尺寸）  | DOM 变化、窗口 resize     |
  | 绘制    | 生成绘制指令（颜色、阴影等） | 颜色、边框、背景变化
  |
  | 合成    | 将图层合成最终画面      | transform、opacity 动画 |

  ---
  JavaScript 回调执行时机

  ## requestAnimationFrame
  - **注册时机**：当前帧
  - **执行时机**：当前帧（微任务之后，渲染之前）
  - **影响范围**：样式修改在当前帧内存中生效，视觉变化在下一帧显示✅

  ## setTimeout/setInterval
  - **注册时机**：当前帧
  - **执行时机**：下一帧（作为宏任务）
  - **影响范围**：执行时可能触发重排重绘

  ## Promise.then (微任务)
  - **注册时机**：当前帧
  - **执行时机**：当前帧（宏任务完成后立即执行）
  - **特点**：微任务队列会清空，可能阻塞渲染

  ## requestIdleCallback
  - **执行时机**：帧预算剩余时间或下一帧开始
  - **用途**：执行低优先级任务，避免阻塞关键渲染

  ---
  重要概念

  合成层

  **GPU加速属性**（如 transform、opacity、filter）可以创建独立的合成层：
  - ✅ **跳过重排和重绘**：不触发布局计算和绘制操作
  - ✅ **直接进入合成阶段**：由GPU直接处理变换和透明度
  - ✅ **性能优化**：避免昂贵的样式重计算和布局计算

  这是因为这些属性的变化不需要影响文档流，只需要在最终的合成阶段应用变换矩阵。

  可利用这些属性优化动画性能，实现60fps流畅动画。

  强回流（触发完整渲染流水线）

 // ❌ 修改几何属性触发布局计算（重排）
 element.style.width = '100px'      // 修改宽度，影响文档流，必须重排

 // ❌ 读取布局信息强制同步回流
 console.log(element.offsetWidth)  // 读取offsetWidth，浏览器必须立即计算布局

 // ❌ 再次修改几何属性，触发第二次回流
 element.style.height = '100px'     // 修改高度，再次影响文档流，再次重排

 原因：width/height等几何属性变化会影响整个文档流布局，浏览器必须重新计算所有相关元素的位置和大小。

**为什么触发两次重排？**

1. **第一次重排**（第193行）：
   - 修改 `width` 属性改变了元素的几何尺寸
   - 浏览器必须重新计算整个文档流的布局（重排）
   - 但此时浏览器可能不会立即执行，而是将重排任务放入队列

2. **强制同步回流**（当前帧执行）：
   - 读取 `offsetWidth` 这样的布局属性会强制浏览器立即执行所有挂起的重排
   - 这是**强制同步布局**，浏览器必须立即计算并返回准确值
   - 此时完成了第一次完整的重排

3. **第二次重排**（第199行）：
   - 修改 `height` 属性再次改变了元素的几何尺寸
   - 由于之前已经强制同步回流，浏览器必须再次进行重排计算
   - 这导致了第二次重排

**重排的本质**：
重排（Reflow）是浏览器渲染流水线中的一个完整布局计算过程，包括：
- 重新计算所有受影响元素的几何属性（位置、大小）
- 更新整个文档流的布局
- 这是一个相对昂贵的操作，会阻塞主线程

**性能优化建议**：
要避免这种多次重排，可以使用：
- 批量修改样式（使用 `requestAnimationFrame`）
- 使用 CSS class 一次性修改多个属性
- 避免在修改布局属性后立即读取布局属性

  批量处理（性能优化最佳实践）

 // ✅ 使用 requestAnimationFrame 在下一帧批量处理
 requestAnimationFrame(() => {
   element.style.transform = 'translateX(100px)'  // GPU加速，跳过重排重绘
   element.style.opacity = '0.5'                  // GPU加速，直接合成处理
 })

 优势：
 - **避免布局抖动**：所有DOM操作在同一帧内完成
 - **利用GPU加速**：transform/opacity跳过重排重绘阶段
 - **保证流畅性**：与浏览器刷新率同步，避免丢帧
 - **批量处理**：减少多次单独操作导致的性能开销

  ---
  帧预算

  | 刷新率   | 帧预算     | 超时后果    |
  |-------|---------|---------|
  | 60Hz  | 16.67ms | 掉帧、卡顿   |
  | 120Hz | 8.33ms  | 更易掉帧    |
  | 144Hz | 6.94ms  | 对性能要求极高 |

  如果一帧内无法完成所有操作，就会出现掉帧，用户感知为卡顿。

  ---
  性能优化建议

  1. **动画使用rAF**：确保与刷新率同步，避免掉帧
  2. **避免微任务阻塞**：不要在微任务中持续产生新微任务
  3. **批量DOM操作**：使用rAF或DocumentFragment批量处理
  4. **使用合成属性**：优先使用transform、opacity等合成层属性
  5. **延迟非关键任务**：使用requestIdleCallback处理低优先级任务
  6. **避免强制同步布局**：不要在修改样式后立即读取布局信息