# C++

```c++
`1.` c++是与操作系统相关联的语言，运行于操作系统中，与操作系统进行交互
`2.` c++可直接操作内存，将数据存储在内存地址上【指针】
`3.` c++提供一些内置库，提供与系统进行交互的功能【iostream,fstream】
`4.` c++ 是强类型语言，需明确定义所声明的变量的类型，以准确分配内存
`5.` c++ 需编译后才能执行
```



### 数据类型

数字类型 + 字符串类型

#### 字符串

##### char

```typescript
`用于表示简单字符`：
容纳单个字符的一种基本数据类型 -2^7 ~ 2^7-1  【】

`编程是英文为基础的，8位2进制数可覆盖所有的字母数字及符号`

signed char: -2^7~2^7-1 【8位2进制可表示的范围，1位符号位，7位实际范围】
unsigned char: 0~2^8-1  【无符号位，全是实际范围】

wchar_t ,char16_t,char32_t:

char16_t ch1 = u'q';
char32_t ch2 = U'q';
```



##### wchar_t

```typescript
`用于表示更复杂的字节`：
char可以表示英文所有的字符，但可能无法表示日文/汉字，因此需要更长的字节，
编译器厂商可以定义wchar_t【宽字符类型】 16位字节
```

#### 数字类型

##### 整数

`-2，2 等整数`   符号位+数字位

```typescript
`int`：整型【有符号】
·······························································
4字节 4*32   【-2^31 ~ 2^31-1】

`unsigned int`:无符号整型
·····················································
4字节 4*32   【0 ~ 2^32】

`long long int`:超长整型
········································
8字节 8*32   【-2^31 ~ 2^31-1】

`unsigned long long int`:无符号超长整型
········································
8字节 8*32   【0 ~ 2^32-1】

`short int`:短整型【有符号】
·····················································
2字节 2*16    【-2^15 ~ 2^15】

`unsigned short int`:无符号短整型
·················································
2字节 2*16    【0 ~ 2^16】
```

##### 浮点数

`-2.15   2.15 等小数`

```typescript
浮点数在内部的存储方法与科学计数法一样 【47281.97  =>4.728197*10^4】
4.728197E4【E前是尾数，E后是10的幂】

`float`:单精度
···················································
4字节【32位 = 8位指数和符号 + 24位非指数部分】  

`double`：双精度
······························
8字节【64位，多出的位数表示非指数部分，提高精度】

`long double`：高双精度
························
8字节
```

#### 强制类型转换

```
static_cast<long> (**) // 将** 强制转换为 long
```



#### bool类型

```typescript
boolean
```

#### string类

```c++
#include<string>;
using namespace std;
string str1;
string str2 = "sgsgs"
cin >> str1;

str1声明了一个长度为0的string对象，但程序将输入读取到str1时，将自动调整str1的长度,这样与使用数组相比，使用string对象更方便，安全    
```

#### 数组

数组类型：存储相同类型数据的一段内存

```typescript
int arr[2] = {34, 45}
int arr2[2][3] = {
    {0, 0, 0},
    {1, 1, 1}
};
`0.` 数组使用{大括号}初始化赋值
`1.` 数组只能在初始化时赋值，之后不支持赋值,但可以通过输入cin 赋值
        int cards[4] = {2,4,6,8};
		int hands[4];
        hands[4] = {1,3,5,7};  // 不允许
`2.` 不能将一个数组赋给另一个数组 
        hands = cards  // 不允许
`3.` 初始化数组时，提供的值少于数组的元素数，编译器将把其他元素设置为0      
`4.` 列表初始化禁止缩窄转换
     long plifsp[] = {25，92，3.0}  // 浮点数赋值给 long
     char slifs[4] = {'h', 'i', 112, '\0'}  // 1122011 超出char表示的范围
     char tlifs[4] = {'h', 'i', 112, '\0'}  //支持，112 会转换为 字符
```

##### 字符串

```typescript
字符串是存储在内存的连续字节中的一系列字符;【c风格字符串】
这意味着可以将字符存储在char数组中【c风格字符串以空字符[\0]结尾】

`1.` 存储在数组中,
   char str[3] = {'b', 'a', 'c'} //  不是字符串
   char str[3] = {'b', 'a', '\0'} //  是字符串
   char str[3] = "abc";
```

##### vector

`STL模板类`

```typescript
vector<typeName> vt(n_elm)

`1.`使用动态存储内存，
`2.`功能强大，但是效率低


#include <vector>
using namespace std;

vector<int> vi;
vector<double> vd(n);    
```

##### array

模板类

```typescript
array<typeName, n_elm> vt

`1.`使用栈(静态内存)，
`2.`

#include <array>
using namespace std;
array<int, 5> ai;
array<double,4> ad = {1.2, 1.3, 1.4, 1.5};    
```

##### 比较

```typescript
数组，vector， array
```

##### 动态数组/静态数组

```typescript
`静态数组`：程序中直接声明的数组,不管后续程序是否使用，都会创建变量并分配内存
`动态数组`：在程序中动态创建的变量【可能不会创建】，使用new 创建变量，分配指针，使用后用delete删除

int *pt = new int;
short *ps = new short[100];
delete pt;
delete [] ps

// 指针访问数组的每一个元素 ps[n]
ps 指向数组的第一个元素的位置
*ps 数组的第一个值
```



#### struct结构

结构类型：存储不同类型数据的

```typescript
相当于js中的对象
`struct` obj{
    int age;
    char name;
}
```

#### 结构数组

[结构]

```
obj arr[10] = [....]
```

#### 共用体

存储不同的数据类型，但只能同时存储其中的一种类型

```typescript
用途：当数据使用两种或者多种格式时，可节省空间
`union` one4all{
    int int_val;
    long long_val;
    double double_val;
}

one4all pail
pail.int_val = 15;     // 存储一个 int类型的值 15
cout << pail.int_val
pail.double_val = 1.38 // 存储一个double类型的值，int_val 丢失

```

#### enum

枚举类型

```typescript

```

### 运算符

#### sizeof

```typescript
返回类型/变量的长度【* bytes】 //返回变量由多少个字节组成
```



#### 运算符重载

```c++
'大多数运算符都可以通过成员或非成员函数来重载'
    
*   运算符的重载【乘，取址】  
<<  运算符的重载【二进制移位，输出】
....    
------------------------------------------------------
class Time{
    private:
    	int hour;
    	int minutes;
    public:
    	Time operator+(const Time &t)const{
            Time sum;
            sum.hour = t.hour + hour;
            sum.minutes = t.minutes + minutes;
            return sum;
        }
}
'重载类的运算符':当class 内 有 operator操作符 时，属于对该类的操作符进行重载，操作符左边是类，右边是参数
 +:
  给类添加成员函数 operator+(...)
    Time time1，time2,time3;
    time3 = time1 + time2;  //类似于调用 Time.operator+(time2)
                            time1是对象，time2是参数
      
      
`--------------------------------------------------------------`
'重载后的运算符必须至少有一个操作数是用户定义的类型?'
      防止用户为标准类型重载运算符
'使用运算符时不能违反运算符原来的句法规则'
'不能创建新运算符 例如oprator**'
'不能重载下面的运算符：'
      sizeof
      .
      .*
      ::
      ?:
      typeid
      const_cast:强制类型转换运算符
      dynamic_cast: 强制类型转换运算符
      reinterpret_cast:  强制类型转换运算符
      static_cast:强制类型转换运算符    
```



### 函数

```typescript
`1.` c++不允许将函数定义嵌套在另一个函数定义中。每个函数的定义都是独立的，所有函数的创建都是平等的。
```

##### 函数原型

函数原型，描述的是函数的接口【函数如何与程序的其他部分交互】;

​                                                       【函数与系统之间的交互：返回值占用的内存，参数】

```c++
类：结构
函数原型：函数    // 指出函数的类型【入参类型，返回值类型】  
变量类型：变量  
   
```

##### 内联函数

```c++
'常规函数':会在执行时，使程序跳到另一个地址(函数地址)，并在函数结束时返回，跳跃需要一定的开销;
'内联函数':编译器将使用相应的函数代码替换函数调用，运行速度更快，但需要占用更多内存;

“关键字”： inline

inline double aquare(double x){return x*x};    

“注意”：
    内联函数不能递归;
```



##### 函数重载(函数多态)

相同的函数名，不同的参数/返回值

```

```

##### 函数模板

类型函数：通过给函数传递不同的类型，控制函数内部变量的类型

```c++
template <typename T>
void Swap(T &a, T &b){
	T temp;
	temp = a;
	a = b;
	b = temp;
}
Swap(2, 3)  // int 类型
Swap<int>(2, 3)  // 显式定义int 类型    
// 交换a，和b的值，而不用考虑 a，b的类型
```

### class

类,c++中的一种复杂数据类型，是面向对象编程中抽象的起源

一个对象是现实世界中一个实体的抽象，一个类是一组对象的`抽象`

```c++
/*
private：私有属性，只能通过public方法设置【class 默认的权限，不设置就是private】
         OOP的目标之一，隐藏数据【封装】
public：公有方法，通过调用来设置私有属性【可认为是对象的对外接口】
         OOP的抽象，对外暴露接口【抽象】
*/

class Point {
    private:
    	int xPos;
    	int yPos;
    public:
    	void setPoint(int x, int y);
    	void printPoint();
};
Point p1;            // 声明 类型为Point 的 p1
p1.setPoint(12, 13); // 通过共有方法设置 p1的私有属性

`1.`成员函数 
    在类的外部为类添加公用方法(接口)
     void Point::updateX(int x){
     		xPos = x;
		} 
    也可在类声明外定义成员函数时，使函数称为内联函数 
      inline  void Point::updateX(int x){
     		xPos = x;
		} 
`2.`内联函数
    定义位于类声明中的函数自动成为内联函数 Point::setPoint 是内联函数
     
```

##### 构造函数

用于在新建对象时初始化对象

```c++
// 定义构造函数
Point::Point(int x, int y){
    xPos = x;
    yPos = y;
};
//使用构造函数
`1.` Point p1 = Point(12, 13);
`2.` Point p1(12, 13);    // 
`3.` 
// 注意
'1.' 构造函数的参数名不能与数据成员的名称相同    
```

##### 析构函数

```typescript
`1.`析构函数用于完成清理，如果构造函数使用new来分配内存，析构函数使用delete来释放内存;
`2.`什么时候调用析构函数由编译器决定
`3.`由于在类对象过期时析构函数将自动调用，因此必须有析构函数，如果未定义，编译器将隐式的声明一个析构函数，
    并在发现对象被删除后，自动定义析构函数

//定义析构函数
Point::~Point(){
    
}
```

##### this

this指针

```c++
每个成员函数都有一个this指针，this指针指向调用对象
```

##### inline

内联函数的意义

```typescript

```

##### static

```typescript

```

##### 模板类 class

```c++

```

##### 继承

```c++
'继承有3种方式'：public公有继承【is-a】，protected保护继承，和private私有继承【has-a】;
```

###### 公有继承【is-a】

```
基类的公有方法将成为派生类的公有成员;
```

###### 私有继承【has-a】

```
基类的公有成员和保护成员都将成为派生类的私有成员。
```

###### 保护继承【】

```
基类的公有成员和保护成员都将成为派生类的保护成员
```

###### 多重继承

```
class SingingWaiter :public Singer, public Waiter{};
```

##### 虚基类

```c++
虚基类使得从多个类(他们的基类相同)派生出的对象只能继承一个基类对象。
class Single ： virtual public Worker{};
class Waiter :  public vietual Worker{};
class SingingWaiter :public Singer, public Waiter{};
```



##### 虚函数

```c++
现象：
    如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法,而不使用为引用/指针类型定义的方法，这称为【动态联编】

工作原理：
    编译器处理虚函数的方法是：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这种数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新韩淑的地址；如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也被添加到虚函数表中。
```

##### protected【访问控制】

```c++
protected:保护成员;
派生类的成员可以直接访问基类的保护成员，但不能访问基类的私有成员
```



```c++
// 基类：TableTenniePlayer
// 派生类:RatePlayer
class RatePlayer:public TableTenniePlayer{
	private:
    	unsigned int rating;
    public:
    	
}; 
.派生类对象存储了基类的数据成员(派生类继承了基类的实现);
.派生类对象可以使用基类的方法(派生类继承了基类的接口);

'构造函数：'  // 派生类构造函数需要基于基类构造函数
            // 需要初始化基类，如果不显式的初始化基类，那会隐式调用基类的构造函数
            // 如下，显式调用，将fn, ln, ht 传递给基类构造函数
    RatePlayer：：RatePlayer(unsigned int r, const string & fn,
                          const string & ln, bool ht):TableTenniePlayer(fn, ln, ht){
    	rating = r;
	}
```



#### 友元

```c++
'为什莫需要友元？'
当在class 中重载 * 的时候，假如第二个参数是 int 类型， time1 * 2 可以被重载运算符感知，但是
2 * time1 无法被感知，但是两个表达式是等价的，因此需要弥补这种情况，需要非成员函数解决;
  time3 = 2 * time2; 
  time3 = oprator*(2, time2)  // 非成员函数运算符重载
'但是有一个问题：'
      非成员函数不能直接访问类的私有数据【但是友元函数可以】
friend Time operator*（int m, const Time & t);  // 将原型放在类声明中
    
```



##### 友元函数

```c++
'通过让函数称为类的友元，可以赋予该函数与类的成员函数相同的访问权限;'

类的友元函数是非成员函数，其访问权限与成员函数相同
    
'友元函数可以看成类的扩展接口的组成部分'    
```

##### 友元类

```

```

##### 友元成员函数

```

```

#### 转换函数

```c++
1.转换函数必须是类方法    // 通过类对象调用，告知函数要转换的值
2.转换函数不能指定返回类型 // 在operator 后已经定义返回类型
3.转换函数不能有参数    // 通过类对象调用，告知函数要转换的值，因此不需要参数
    
operator double(){

}
```



### 命名空间

```typescript

namespace Jack{
    double pail;
}
namespace Jill{
    double fetch;    
}
// 为名称空间，添加成员【再次声明一个名称空间，加入数据即可】
namespace Jack{
    double age;
}    
    
Jack::pail; // 使用作用域解析符访问    
'名称空间可以是全局的，也可以是位于另一个名称空间中，但不能位于代码块中。因此，默认情况下。在名称空间中声明的名称的链接性为外部的'    

'c++提供了两种机制(using声明和using编译指令简化对名称空间中名称的使用)'
   1. using std::cout;
   2. using namespace std;
       
```

### 编程原理

#### OOP

面向对象编程

```typescript
面向对象编程是以类为核心设计的数据模型

`类`： 强调数据【对象】为中心，以类为【数据模型】，构建满足情况的类，对象是类的实例
`类的属性`：公有，私有，被保护
`继承`：旧类派生出新类
`多态`：
```

#### 泛型编程

```typescript
`独立于特定类型的代码`

`例如`：对不同类型的数据进行排序，泛型编程对语言进行扩展，以便只编写一个泛型函数，应用于各种实际类型

```

### 指针

```typescript
计算机在存储时必须跟踪的三种基本属性：
    1.信息存储在何处
    2.存储的值为多少
    3.存储的信息是什么类型的
我们通过一种策略来达到上述目的：定义一个变量。声明语句指出了值的类型和符号名，还让程序为值分配内存，
并在内部跟踪该内存单元。
`常规变量`：值是指定的量，地址是派生量
`指针策略`：地址是指定的量，值是派声量

指针策略：
int update = 6;
int *p_update= &update;  // 声明一个 int 类型的变量 *p_update，值为6 ，

cout << upadte << " || " << *p_update    //  6 || 6
cout << &update << " || " << p_update    // 0x0065fd48 || 0x0065fd48
    
普通变量 存储值，使用取址符号：& 获取 地址
指针变量 存储地址，使用符号：* 获取值
```

#### new

动态分配内存

```typescript
int *pt = new int  //  new 根据 后面的int 确定需要的内存大小，然后找到这样的内存，并返回其地址
```

#### delete

释放内存

```
int *ps = new int;
delete ps

释放ps指向的内存，但不会删除ps指针本身，可以将ps重新指向另一个新分配的内存块;
不能使用 delete 释放变量声明的内存;

```

#### 指针，数组和指针算数

```c++
整数变量+1， 其值+1;
int count = 1;
count = count + 1;    //4

指针变量+1，增加的值等于他所指向的类型的字节数;

int *cArr = new int[3];  // 将数组名cArr 解释为数组第一个元素的地址
cArr = cArr +1;   // cArr指向第二个元素的地址


```

#### 结构

```c++
当使用 new 创建 结构时，会创建一块可以容纳结构的内存，返回一个地址给指针:
  inflatable *ps = new inflatable;          
如何访问结构成员:
  1. 通过指针访问
     `箭头成员运算符`：->
        ps->price；
  2. 通过结构访问:
    (*ps).price;
```



### 内存

#### 自动存储

```
函数内部定义的常规变量使用自动存储空间，在函数被调用时自动产生，函数结束时消亡;
自动变量存储在栈中，执行代码块时，变量依次加入栈中，离开代码块时，按照相反的顺序释放这些变量
```

#### 静态存储

```typescript
静态存储是整个程序执行期间都存在的存储方式，使变量成为静态的方式：
`1.`函数外边定义它
`2.`声明变量时使用关键字static
```

#### 动态存储

```typescript
new 和delete，管理的内存池被称为自由存储空间/堆。该内存池同自动变量和静态变量的内存是分开的。

`自动存储`使用栈自动添加/删除机制使内存是连续的
`动态存储`导致占用的自由存储空间不连续，使跟踪新分配内存的位置更困难
```

### 作用域

##### 作用域解析运算符 ::

```c++
namespace Jack{
	void fetch(){
        ....
    }
}
Jack::fetch();

'当在变量名前使用::，表示使用变量的全局版本'
```

##### static

```
static 声明变量时，可确定变量的作用域
```



### 关键字

1. 关键字符

   ```
   &： 取址，引用
   *： 指针
   ```

   

2. virtual

   ```c++
   virtual 可声明虚函数;
   --------------------------------------------------
   如果要在派生类中重新定义基类的方法，通常应将基类的方法声明为虚的，这样，程序将根据对象类型而不是引用或指针的类型来选择方法。为基类声明一个虚析构函数也是一种惯例。:
   BrassPlus ophelia;
   Brass * bp;
   bp = &ophelia;
   bp->ViewAcct();  // ViewAcct是虚方法，程序将根据对象(bp)类型【BrassPlus】选择方法
                    //  BrassPlus.ViewAcct
                   //   而不是引用或指针类型【Brass】    
   '这种属于动态联排'   
   ```

   

3. operator

   ```
   operator 可定义重载运算符，也可定义类型转换函数
   ```

   

4. #include

   ```
   #include <iostream> // 编译指令告诉预处理器，该程序需要包含 <iostream>库
   预处理编译指令
   ```

5. #define

   ```
   #define INT_MAX 32767 // 该编译指令告诉预处理器，在程序中查找INT_MAX，并将INT_MAX都替换成32767
   
   预处理编译指令
   ```

   

6. #ifndef

   ```c++
   用来判断头文件是否已被引入【ifndef】，未被引入就执行【define】后的内容;
   如果已被引入，就在执行【endif】;
       
       
   #ifndef COORDIN_H
   #define COORDIN_H
   .....
   #endif    
       
   ---------------------
   #ifndef:  if no define
   ```

   

7. explicit

   ```
   关闭隐式转换
   ```

   

8. const

   一种限定符

   ```c++
   const 限定符对默认存储类型有影响：默认情况下全局变量的链接性为外部，但const全局变量的链接性为内部
   const int fingers = 10;  // 类似于 static const int fingers = 10；
   int main(){
   
   }
   ```

   

9. mutable

   ```c++
   可用来指出，即使结构(或类)变量为const，某个成员也可被修改
   struct data{
       char name[30];
       mutable int accesses;
   }
   ```

   

10. extern

    ```c++
    '引用声明'：使用外部定义的变量;
    当使用extern 关键字 修饰一个外界已有的变量，不会在当前作用域重新生成一个同名的变量，而是引用已有的变量。    
    ```

11. typedef

    ```c++
    // 类型别名
    typedef char byte
    ```

12. auto

    ```
    不指定变量类型，编译器将把变量的类型设置成与初始值相同;
    auto n = 100  // int
    ```

13. const

    ```typescript
    限定符，限定了声明的含义
    ```

14. 多少

### 变量

#### 自动变量

```c++
'函数执行过程中声明的变量;'
会在函数执行时生成，函数执行结束后销毁;
```

#### 静态存储持续性变量

```c++
'外部链接性'：可在其他文件访问【global】
    需要在代码块的外面声明它;
'内部链接性'：只能在当前文件访问【one_file】
    需要在代码块的外面使用static声明它
'无链接性'：只能在当前函数/代码块中访问【count】    
	代码块的内部使用static声明 
    
'在代码块的内部使用static 和不使用static的【自动变量】区别？'
    在函数中使用static声明的变量，即使函数未执行，声明的变量也留在内存中;
'静态持续变量的特征？'
    未被初始化的静态变量的所有位都被设置为0，这种变量被称为零初始化的
'无链接性的作用?'
    该变量在代码块中始终存在【不管函数是否运行，在调用函数时只会初始化一次，因此可以在函数中共享】
```



#### 引用

```c++
&： 用于类型后，变量前，表示引用;
int rate;
int & rodents = rate;

'注意'：需要在声明引用时初始化
    
`使用情况`：
    数据对象小【内置类型/小型结构】，按值传递;
	数据对象是数组，，使用指针传值【唯一选择】，并将指针声明为指向const 的指针;
	数据对象是较大的结构，使用const指针/const引用，以提高程序效率
    数据对象是类对象，使用const引用    
```

### 强制类型转换

```
在 class 中重载运算符【使用友元，不使用友元】
```

### 静态联排和动态联排

```

```



# c++标准库

`c++标准库 = STL库 + 标准函数库；`

在c++使用过程中，对通用的功能，进行规范化封装，制定成c++标准，供使用者进行调用；



## STL库

STL 六大组件(components):  

`容器(Containers)`， `算法(Algorithms)`，`分配器(Allocators)`， `迭代器(Iterators)`，

`适配器(Adapters)`，`仿函数(Functors)`

```typescript
`六大组件关系`：
    容器通过适配器取得存储空间，
    算法通过迭代器存取容器内容
    仿函数可以协助算法完成策略变化
    配接器可以修饰或套接仿函数
```

## 标准函数库

### iostream

#### cin

```typescript
`cin.getline(存储输入的变量, 读取的字符数)`:面向行输入，通过回车键输入的换行符来确定输入结尾，
                                       但不保存换行符
    cin.getline(name, 20) // 读取19个字符，最后一个空间存储空白符
`cin.get`:和getline类似，但不丢弃换行符，而是将其留在输入队列中
```

