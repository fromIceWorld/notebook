// 初始时有 n 个灯泡处于关闭状态。
// 第一轮，你将会打开所有灯泡。
// 接下来的第二轮，你将会每两个灯泡关闭一个。

// 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。
// 第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。
// 直到第 n 轮，你只需要切换最后一个灯泡的开关。

// 找出并返回 n 轮后有多少个亮着的灯泡。

/**
 * 每次切换的都是 n 的倍数的灯泡
 *
 * */

//              1，2，3，4，5，6，7，8，9
// 1   全部亮
// 2   2的倍数  2，4，6，8
// 3   3的倍数  3，6，9
// 4   4的倍数  4，8
// 5   5的倍数  5
// 6   6的倍数  6

// 7   7的倍数  7
// 8   8的倍数  8
// 9   9的倍数  9
// 根据每一轮的切换后可能不变，可能反转
// 设置 容器，单次存储，偶次抵消，剩余的size就是关闭的灯泡
//

/**
 * @param {number} n
 * @return {number}
 */
var bulbSwitch = function (n) {
    // n => 0,1
    if (n <= 1) {
        return n;
    }
    // >=2
    let set = new Set();

    for (let i = 2; i <= n; i++) {
        let from = i;
        // 查找 i 的倍数
        while (from <= n) {
            if (from % i == 0) {
                if (set.has(from)) {
                    set.delete(from);
                } else {
                    set.add(from);
                }
            }
            from = from + i;
        }
    }
    return n - set.size;
};
// 倍数思考👆，爆栈

// 约数思考👇
// 每一个灯的 灭和亮取决于k的约数的个数，如果k的约数是奇数，灭💡，k的约数的个数是偶数，亮💡
// 思维转化，求 0-n 之间的各个数的约数的个数；
// 再简化 如果k有约数x，那么必然有约数 k/x；因此必是偶数；只有 x^2 = k 时，约数为奇数
// 因此 就简化为 k如果有平方根，那么k必是灭的

// Math.floor(Math.sqrt(n))  是 1-n 之间的完全平方数的个数 【数论推论】
// 1-n的完全平方数的个数 有 0- Math.sqrt(n):
// 1-n的完全平方数中的最大值是平方n 的约数是Math.sqrt(n),因此，所有的完全平方数是 1-Math.sqrt(n)

var bulbSwitch = function (n) {
    return Math.floor(Math.sqrt(n));
};
