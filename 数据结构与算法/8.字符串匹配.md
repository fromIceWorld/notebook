# 字符串匹配

```typescript
字符串A,【长度n】
字符串B,【长度m】

在字符串A中找字符串B出现的位置，次数


```

## 暴力(BF算法)

```typescript
逐字符串比较：
`复杂度`：每次比较字符串需要比较每个字符是否相同【m次】，需要比较【n-m+1次】
        m*(n-m+1)
         ||  【n远远大于m】
        m*n

`没有从之前的错误中学到信息`
```

## KMP算法

```typescript
`根据比较信息，减少后续比较次数`【在错误中学习】
主串:S     ababaabaabac 
模式串：P   abaabac

第一次比较在索引4处匹配失败【前3位匹配成功】，"aba" 是成功串
        前缀：a,ab
        后缀：a,ba 
     公共串： a
     
👆：是在匹配失败后得到有用信息的逻辑，称为next数组
    next[i]:代表 p[0]-p[i] 代表的子串的 前k项和后k项匹配的最大长度【也就是前缀和后缀的匹配】

 
     
`1.` 每次比较结束后，根据匹配的信息，找到需要移动的索引，减少无效匹配【如何确定移动的索引???】
`2.` 对匹配成功后的字符串的前缀和后缀进行比较，求出最大长度



`关键点：`快速构建next数组, P串从1开始与自身【主串】比较【n复杂度】
         next[0] = -1; 初始化为-1 【0无意义，因为是比较前缀，后缀】      

         P【主串】      i指针，指向P字符的位置【i初始是1】
         P1【模式串】    j指针，指向P1字符的位置【j初始是0】
         先比较 i=1,j=0 : 如果相等,next[i] = 1   
                            不等，next[i] = 0;  
                         i++,j++
         再继续比较:   相等，next[i] = j   // 相等说明，j及j前都匹配成功，所以长度为j      
                     不等, j = next[j] // 在j点不匹配时，证明在j前是可以匹配成功的，因此需要挪动next[J]
         


`next数组的本质：` 将匹配成功的字符串进行前缀，后缀的匹配【相当于对P进行前缀，后缀自匹配】
                 只需求出next数组，后续根据匹配成功的字符串，与next对比即可【 m+n 复杂度】
```

#### 题

##### 686.重复叠加字符串匹配