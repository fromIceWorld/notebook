#### 【递推，贪心，搜索，动态规划】

```typescript
每个阶段只有一个状态 -> `递推`: 【斐波那契数列】
每个阶段的最优状态是由上一个阶段的最优状态得到的 -> `贪心` 
每个阶段的最优状态是由之前所有阶段的状态的组合得到的 -> `搜索`
每个阶段的最优状态可以从之前某个阶段的某个状态或或某些状态直接得到而不管之前的这个状态是如何得到的 —> `动态规划` 

每个阶段的最优状态可以从之前某个阶段的某个或某些状态得到：`最优子结构`
而不管之前这个状态是如何得到的：`无后效性`
```

### 动态规划

```typescript
根据递推逻辑，确定遍历顺序;【516】

例：516.最长回文子序列
	递推逻辑：dp[i][j] <= dp[i+1][j-1] + 2
	         i+1 => i
	         j-1 => j
	    因此i 是逆序的,j是顺序的    

递推子元素：1. 以某一个索引结尾
          2. 某一段范围
```



#### 背包问题

##### 0-1背包问题

```typescript
一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

`0`：dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
`1`：状态转移：dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) // max(不装当前物品，装入当前物品)

思路：每一个物品都分为两个状态，装或者不装；
	  不装：当前i最大价值是 i-1的最大价值。
      装：分为装的下，和装不下。
      		装的下，比较装下后价值加上剩余容量的最大价值
			装不下，就和不装一样
 因此： dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i])        

由画二维表，可看出，i 取决于 i-1层的数据，
    
-----降维------
可用滚动数组 代替二维表，存储数值【但由于滚动数组会对数据进行覆盖，因此需要逆序遍历】

for(i to N){
    for(j - 0){
        d[j] = max(d[j],d[j-w[i]])+v[i]
    }
}
```

###### 恰好装满的背包问题

```typescript
leetcode：
`1`：给定一个只包含正整数的非空数组。问是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
```

##### 完全背包问题

```typescript
`与 0-1 不同点`：每种物品有无限种

`0`：dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
`1`：状态转移：不装：和【0-1背包】一样；d[i-1][j]
			 装：因为可以装入无限个，所以状态不是转移到【dp[i−1][j−w[i]]+v[i]】
                而是转移到 dp[i][j−w[i]]+v[i]

`不同点`：因为是无限种，状态转移要转移到自身

--------降维---------
 同样可用滚动数组降维，但是由于状态转移方程的与【0-1背包不同】，因此j需要顺序遍历

` -------另一种思路1-----`
 因为物品是无限的,我们可以取k件物品【k=1,2,3,4,5......】 
 
d[i][j] = max{dp[i-1][j-k*w[i]] + v[i]*k}

优化：逆向遍历
再优化：用多个2的次方[1，2，4，8，16，....] 来表示 0-k


```

###### 恰好装满的完全背包问题

```typescript
leetcode：
`1`：一个价值amount和一些面值【n种】，假设每个面值的硬币数都是无限的，问我们最少能用几个硬币组成给定的价值。

`------恰好装满：背包剩余空间为0----`
只有背包容量为0才是正确解，其他容量的背包全是非法解，

将dp[0，...N][0]初始化为0,其他全是错误解，初始化为 -infinity

`----思路2：n指针------`
n个指针 指向 n个面值
每次求出 min(n*面值1，n*面值) + 当前值。直到 amount。
```

##### 多重背包问题

```typescript
`不同点`：每种物品的数量是有限个
`思路1`：可转换为【0-1】背包问题，将有限数量n的物品分为n种物品
		优化1：滚动数组
		优化2：将n种物品拆分成由 2^l + 2^l2 + ... = n；分为不同的包，

```

##### 二维背包

```typescript
背包的限制 变为两个条件：

有字符串数组：[‘**’，‘**’，‘**’]；字符串由0和1组成
有m*0，n*1
求能组成的

`相对于【0-1背包】，j被拆分成 两个条件 m 和 n`

```

#### 【双指针，二分法，回溯法】

###### Math.abs(a-b)：绝对值

#### 【广度优先搜索】

```typescript
`1.` 完全平方数
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
-------------------------------------------------------------------------------------
【四平方原理】：任何整数都可以表示成不超过四个整数的平方之和。
因此 答案是：1，2，3，4【只有四种可能】

广度优先搜索方法：将n 不断地用小于 n 的平方组合假设n = 13，小于n 的数 1*1 2*2 3*3
一层：                                         13
二层 :                 12                      9                          3
三层：   11      8         3                8     5     0             2    X
13 = 3*3 + 2*2

---------------------------------------------------
动态规划：dp[i] = min(i,dp[i-j*j]+1)    

```

