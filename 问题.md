# 1.前端处理10万条数据

```
①定时器
拿到10万条数据后，分组确定每一组的数量，递归调用requestAnimationFrame,与浏览器的帧率配合渲染数据，使动画自然流畅。
优点:渲染后可在前端同时操作这大批量数据。

②触底请求
监听滚动事件,当滚动条触底时,触发请求,渲染下一批数据
wheel:监听的是滚轮，不管是否真实滚动，都会触发
scroll:卷动，只有内部的元素真实滚动时才会触发，与overflow：scroll有关


③虚拟滚动
将渲染区域，分为上，中，下区域，中是用户可以看到的区域,上，下是缓冲区域。
建立一个根据每一项长度*数据量=总高度的一个空的box，撑起一个真实滚动条,监听容器的滚动事件,根据滚动的高度和每一项的高度确定应该加载的数据，
使用requestAnimationFrame优化动画

缺点:列表项包含异步加载的图片/展开行/树结构时,高度计算会变的困难
```

# 2.OAuth2 双token

```
双token与jwt无关

双token是出现在特定场景下的，在OAuth2体系中，token的签发者和验证者不是一个实体，
要求验证者(资源服务器)每次去签发者(授权服务器)上去校验token不太现实，所以利用jwt进行无状态验证，

access_token随处要用，增大了泄露的风险，所以有效期短，防止泄露,refresh_toke专用刷新，很少出现在网上，泄露风险小，
中间人窃取refresh_toke难度高，即使拿到access_token也很快失效，权限泄露风险可控。
```

# 3.特定间隔执行程序,输出固定格式时间

```typescript
`使用requestAnimationFrame。`
padStart格式化文字 '2'.padStart(2,'0')  => '02'

因为setTimeout 和 setInterval 都是在特定间隔后把回调函数放入栈中,如果栈被阻塞，执行会超出预期。
如果非要使用的话，需要每一次调用时,与之前的time做对比，进行时间校验，查看是否超时。
requestAnimationFrame 是与浏览器的渲染帧相结合，执行的更频繁,优先级更高[微任务]。
```

# 4.判断函数是否被标记位async

```typescript
async name(){}
({}).toString.call(async)

'[object AsyncFunction]'
```

# 5.数据类型检测

## typeof

```typescript
`typeof 操作符是按照数据在计算机底层存储的二进制结果来进行检测的`
对象类型在浏览器底层的存储的二进制都是000开头，所以基于typeof检测对象类型的结果都是"Object"，这就导致typeof无法细分对象和数组。


优点：
能检测出 `number`,`boolean`,`string`,`symbol`,`undefined`,`function`,`object`

缺点：
`null`,`Array`,`AsyncFunction`等类型 检测不出
基础数据类型，null返回object，其他都可以返回正确结果
引用的数据类型，除了function，其它都返回object[例如正则,数组]
function都返回function类型[例如 async类型的function]
```

## instanceof

```typescript
obj instanceof 构造函数

用于测试构造函数的prototype属性是否出现在`对象`的原型链中

优点：
可以检测出特定的引用类型的具体类型

缺点：
只能用于对象类型的检测，无法检测基本数据类型。
无法检测undefined和null
`存在很多问题,因为object也出现在arr的原型链上`
原型链可自定义

[] instanceof Object  true


function myInstncaeof(obj，fn){
    let prototype = fn.prototype;
    let proto = obj.__proto;
    while(__proto__){
		if(__proto__ == prototype){
            return true;
        };
        proto = proto.__proto__
	}
    return false;
}
```

## constructor

```typescript
(1).constructor === Number      true
('1').constructor === String    true
([]).constructor === Array      true
(()=>{}).constructor === Function
(async function  name(){}).constructor  === AsyncFunction
优点：
基本上基本数据类型和引用数据类型都可以检测，但是`除了自定义的对象`和一些特殊的类型 `AsyncFunction`

缺点：
`AsyncFunction`不是一个普通变量,不可以直接使用。
undefined，null无法检测
constructor是通过获取数据的构造函数来确定数据的类型,自定义对象的constructor是不可靠的，可以自定义的

function Name(){};
let name1 = new Name();
name1.constructor === Name 
name1的构造函数是Name。不符合
```

## ({}).toString.call()

Object.prototype.toString.call() 

```typescript
({}).toString.call(async function  name(){}) ==> '[object AsyncFunction]'

优点：
大部分的数据类型都可以检测
缺点：
Object.prototype.toString函数是允许被修改的。
`*`自定义的类是不能准确判断的,可以采用[Symbol.toStringTag]给构造函数添加tag

function Name(){};
let name1 = new Name();
({}).toString.call(name1)                //[object Object]

//自定义[Symbol.toStringTag] 
Name.prototype[Symbol.toStringTag] = 'my'
({}).toString.call(name1)                //[object my]


class ValidatorClass {
  get [Symbol.toStringTag]() {
    return 'Validator';
  }
} 
({}).toString.call(new ValidatorClass())  //[object Validator]

```

类型检测：typeof检测基础类型，toString检测object，function。

# 6.js实现Ajax并发请求限制

```typescript
const tasks = [
    () =>
        new Promise((resolve, reject) => {
            setTimeout(() => resolve(0), 2000);
        }),
    () =>
        new Promise((resolve, reject) => {
            setTimeout(() => resolve(1), 1000);
        }),
    () =>
        new Promise((resolve, reject) => {
            setTimeout(() => resolve(2), 5000);
        }),
    () =>
        new Promise((resolve, reject) => {
            setTimeout(() => resolve(3), 1000);
        }),
];

class myTask {
    max;
    running = 0;
    results = [];
    index = 0;
    count = 0;
    constructor(max = Infinity, tasks = []) {
        this.max = max;
        this.tasks = tasks;
    }
    run() {
        return new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            while (this.index < this.tasks.length && this.running < this.max) {
                this.next();
            }
        });
    }
    next() {
        if (this.count == this.tasks.length) {
            this.resolve(this.results);
        } else if (this.index < this.tasks.length && this.running < this.max) {
            this.running++;
            let index = this.index;
            this.index++;
            console.time(index);
            Promise.resolve(this.tasks[index]()).then((result) => {
                console.timeEnd(index);
                this.results[index] = result;
                this.running--;
                this.count++;
                this.next();
            });
        }
    }
}
console.time('start');
let task1 = new myTask(2, tasks);
task1.run().then((results) => {
    console.log(results);
    console.timeEnd('start');
});

分步骤：
1. 直接推进去最大运行数的promise
2. 当有promise运行完成后，判断是否已经全部运行完毕,未完毕就将下一个promise推入
```