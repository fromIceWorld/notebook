# 依赖注入树

在Angular中，有一颗依赖注入树，与组件树平行。

Angular的依赖注入，依靠拓展的TS语法

## PlatformRef 依赖注入

```typescript
platformBrowserDynamic()，`平台依赖`,由两部分组成：
`1.` 内置的服务提供商：【PlatformRef，TestabilityRegistry，Console】
                    【CompilerFactory】 (JIT | AOT)
                    【initDomAdapter,document】
`2.` 后续注入的依赖：
    @Injectable({
        providededIn: 'platform'
    })
```

### NgZone【Injector】

```typescript
NgZone依赖，父级是`平台依赖`👆
```

#### Module【Injector】【正常加载的模块】

```typescript
AppModule 的依赖
`1.` @Injectable({
       providedIn:'root'
     })
`2.` @NgModule 的 providers配置
`注意`： @Injectable 中的 providedIn 属性高于 @NgModule 的 providers
        @Injectable 中的 providedIn 可以做 tree-shaking   

`@Injectable`tree-shaking原理：当providedIn = 'root'，在组件中注入时，查找到AppModule，根据token【class service{}】，去查询class 的 providedIn 属性，如果符合providedIn参数规格，就注册到records中。
```

#### Module【Injector】【懒加载模块】

##### Element【Injector】

```typescript
`1.` 通过@Directive() 或 @Component() 中的 providers 属性中配置
`注意`：如果在组件中声明了 一个**服务，那每个组件都会有一个自己的 **服务实例【features】

ElementInjector是元素注入器，当组件/指令需要解析依赖时，会调用allProviders|publicProviders，向上遍历父视图元素，直到父视图等于null，则返回startView【根视图】，然后检查startView.root.injector，当没有找到时，再去startView.root.ngModule.injector。

搜索视图的父元素而不是元素的父视图？？？
`路由加载的组件又是另一种处理方式`
```

